<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[a t a s c o]]></title>
  <link href="http://atasco.github.io/atom.xml" rel="self"/>
  <link href="http://atasco.github.io/"/>
  <updated>2014-06-06T20:51:52+02:00</updated>
  <id>http://atasco.github.io/</id>
  <author>
    <name><![CDATA[alcher]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Backup de postgresql en VCSA]]></title>
    <link href="http://atasco.github.io/blog/2014/05/23/backup-de-postgresql-en-vcsa/"/>
    <updated>2014-05-23T21:13:51+02:00</updated>
    <id>http://atasco.github.io/blog/2014/05/23/backup-de-postgresql-en-vcsa</id>
    <content type="html"><![CDATA[<p>Cuando se realiza el despliegue de un vCenter con el appliance de VMWare (vCenter Server Appliance 5.X) es interesante (cuando no imprescindible) realizar backups periódicos de la base de datos incorporada (postgresql)<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> con el fin de poder hacer una recuperación rápida en caso de <em>accidente</em>.</p>

<p>En esta entrada se recoge la forma de hacer esta copia de seguridad así como la recuperación correspondiente si llega a ser necesario.</p>

<!-- more -->


<h2>Requisito previo</h2>

<p>Es preciso disponer de acceso vía SSH al vCenter. Para habilitarlo:</p>

<ol>
<li>Acceder a la consola web del VCSA (<a href="https://VCSA:5480">https://VCSA:5480</a>)</li>
<li>En la pestaña <em>Admin</em>, pulsar <em>Toggle SSH login</em> para permitir acceder al servidor a través de SSH</li>
</ol>


<h2>Copia</h2>

<p><strong>1.</strong> Acceder al vCenter e ir al directorio donde se encuentran los binarios de postgresql:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nb">cd</span> /opt/vmware/vpostgres/1.0/bin
</span></code></pre></td></tr></table></div></figure>


<p><strong>2.</strong> Para ver la configuración de la base de datos ejecutar el comando:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>cat /etc/vmware-vpx/embedded_db.cfg
</span></code></pre></td></tr></table></div></figure>


<p><strong>3.</strong> Parar el servicio del vCenter:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>service vmware-vpxd stop
</span></code></pre></td></tr></table></div></figure>


<p><strong>4.</strong> Realizar la copia:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>./pg_dump EMB_DB_INSTANCE -U EMB_DB_USER -Fp -c &gt; VCDBBackupFile
</span></code></pre></td></tr></table></div></figure>


<p>Donde <em>EMB_DB_INSTANCE</em> y <em>EMB_DB_USER</em> se sustituyen por los valores obtenidos en el punto <strong>[2]</strong>. <em>VCDBBackupFile</em> es el nombre del fichero donde se guardará el backup.</p>

<blockquote><p>./pg_dump VCDB -U postgres -Fp -c > /tmp/VCDBackUp</p></blockquote>

<p><strong>5.</strong> Arrancar el servicio del vCenter:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>service vmware-vpxd start
</span></code></pre></td></tr></table></div></figure>


<h2>Recuperación</h2>

<p><strong>1.</strong> Acceder al vCenter e ir al directorio donde se encuentran los binarios de postgresql:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nb">cd</span> /opt/vmware/vpostgres/1.0/bin
</span></code></pre></td></tr></table></div></figure>


<p><strong>2.</strong> Para ver la configuración de la base de datos ejecutar el comando:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>cat /etc/vmware-vpx/embedded_db.cfg
</span></code></pre></td></tr></table></div></figure>


<p><strong>3.</strong> Parar el servicio del vCenter:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>service vmware-vpxd stop
</span></code></pre></td></tr></table></div></figure>


<p><strong>4.</strong> Restaurar la copia:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">PGPASSWORD</span><span class="o">=</span><span class="s1">&#39;EMB_DB_PASSWORD&#39;</span> ./psql -d EMB_DB_INSTANCE -Upostgres -f VCDBBackupFile
</span></code></pre></td></tr></table></div></figure>


<p>Donde <em>PGPASSWORD</em> y <em>EMB_DB_INSTANCE</em> se sustituyen por los valores obtenidos en el punto <strong>[2]</strong>. <em>VCDBBackupFile</em> es el nombre del fichero donde se ha guardado previamente el backup.</p>

<p>Utilizar comillas simples <strong>[&lsquo;]</strong> con la password tal como aparecece en el fichero de configuración del punto <strong>[2]</strong>.</p>

<blockquote><p>PGPASSWORD=<code>'g&lt;T4EuybGsA=kG$G'</code> ./psql -d VCDB -U postgres -f /tmp/VCDBackUp</p></blockquote>

<p><strong>5.</strong> Arrancar el servicio del vCenter:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>service vmware-vpxd start
</span></code></pre></td></tr></table></div></figure>


<h2>Referencias</h2>

<p><a href="http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=2034505">Backing up and restoring the vCenter Server Appliance (vPostgres) database (2034505)</a></p>

<p><a href="http://pubs.vmware.com/vsphere-55/index.jsp?topic=%2Fcom.vmware.vsphere.vcenterhost.doc%2FGUID-8DC793FF-1E00-43A1-B85C-070414B9F9B0.html&amp;resultof=%22Enable%22%20%22enabl%22%20%22Disable%22%20%22disabl%22%20%22SSH%22%20%22ssh%22">Enable or Disable SSH Administrator Login on the VMware vCenter Server Appliance</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Si en la instalación se decide hacer uso de la misma, ya que también existe la posibilidad de utilizar otros motores de bases de datos como <a href="http://es.wikipedia.org/wiki/Oracle_Database">oracle</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tráfico unicast en switches]]></title>
    <link href="http://atasco.github.io/blog/2014/03/12/switch-unicast/"/>
    <updated>2014-03-12T18:25:00+01:00</updated>
    <id>http://atasco.github.io/blog/2014/03/12/switch-unicast</id>
    <content type="html"><![CDATA[<p>Realizando una auditoría en la red para determinar su estado se observa, en el equipo en el que se está realizando la captura, tráfico unicast destinado a otros equipos.</p>

<p>Este tráfico es bastante elevado en la <em>VLAN de Internet</em>, mientras que en las <em>VLANes de Servicio</em> el tráfico unicast recogido es el normal en una red conmutada.</p>

<p>Aunque el tráfico unicast detectado no provoca problemas en la red, si es importante conocer la causa del mismo a fin de evitarlo en lo posible.</p>

<blockquote><p>Aunque la estabilidad y el rendimiento de la red no se ve afectado, la presencia de tráfico unicast evidencia un agujero de seguridad importante que es preciso subsanar.</p></blockquote>

<!-- more -->


<h1>Funcionamiento básico de un switch</h1>

<p>Un switch es un dispositivo de red de capa 2, es decir, procesa y envía los paquetes basándose en las direcciones MAC.</p>

<p>Un switch &ldquo;aprende&rdquo; a lo largo del tiempo donde se encuentran las MACs destino de los paquetes (a que puerto está esa MAC conectada) a medida que el tráfico atraviesa sus puertos . Si desconoce donde se encuentra una MAC destino envía paquetes unicast (<em>unicast flooding</em>) a todos los puertos (excepto a aquel del que proviene el paquete) y cuando se recibe la respuesta de vuelta registra la MAC asociada a ese puerto <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<p>Por ejemplo, si un <em>host A</em> envía un paquete a un <em>host B</em> conectado a la misma VLAN de un switch, inicialmente la tabla CAM del switch se encuentra vacía y el switch reenvía el paquete a todos sus puertos.</p>

<p><img src="http://atasco.github.io/images/posts/switch_traffic_1.png" alt="Tráfico switch: IDA" /></p>

<table>
<thead>
<tr>
<th align="left">MAC            </th>
<th align="right"> Puerto</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">0000.00c0.0001 </td>
<td align="right"> Fa0/1</td>
</tr>
</tbody>
</table>


<p>Cuando el <em>host B</em> recibe el paquete responde al <em>host A</em> momento en el que el switch también aprende la MAC del mismo.</p>

<p><img src="http://atasco.github.io/images/posts/switch_traffic_2.png" alt="Tráfico switch: VUELTA" /></p>

<table>
<thead>
<tr>
<th align="left">MAC            </th>
<th align="right"> Puerto</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">0000.00c0.0001 </td>
<td align="right"> Fa0/1</td>
</tr>
<tr>
<td align="left">0000.00c0.0002 </td>
<td align="right"> Fa0/2</td>
</tr>
</tbody>
</table>


<p>Un switch &ldquo;olvida&rdquo; las direcciones MAC aprendidas después de un tiempo<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> de modo que el switch necesita ser capaz de aprender de nuevo en que puertos se encuentran las MACs. Cuando esto sucede, comienza de nuevo el proceso de inundar todos los puertos con tráfico unicast para esperar la respuesta del equipo con la MAC correspondiente y aprenderla de nuevo. Esta es la razón por la que se produce tráfico unicast cada cierto tiempo<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</p>

<h1>Orígenes del tráfico unicast</h1>

<p>La presencia de tráfico unicast puede ocurrir por diversas causas en una red, lo importante es diferenciar cuando este tráfico esta dentro de parámetros normales y cuando puede provocar problemas.</p>

<p>En los siguientes puntos se recogen aquellas causas que pueden dar lugar al llamado <em>unicast flooding</em> causante de posibles problemas.</p>

<h2>Rutas asimétricas</h2>

<p>Se produce esta situación cuando un paquete sigue una ruta de origen a destino distinta a la ruta de vuelta al origen (esto ocurre habitualmente en redes enrutadas, capa 3).</p>

<p>Para entender el proceso que da lugar a esta situación hay que recordar que en un dispositivo de capa 3 (router) existen dos tablas<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>:</p>

<ul>
<li><p><strong>ARP (Address Resolution Protocol):</strong> Mantiene las relaciones entre las direcciones IP y las direcciones MAC con la finalidad de facilitar las comunicaciones IP en un dominio de broadcast (capa 2)<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>.</p></li>
<li><p><strong>CAM (Content Addressable Memory):</strong> Mantiene las relaciones entre las direcciones MAC y el puerto(s) físico del switch<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>.</p></li>
</ul>


<blockquote><p>Por alguna oscura razón, en los switches Cisco con capacidades de routing (capa 3) el valor por defecto para la permanencia de las entradas en la tabla ARP es de 4 horas mientras que el tiempo de permanencia por defecto en la tabla CAM es de sólo 5 minutos.</p></blockquote>

<p>Vamos a centrarnos en el siguiente esquema para entender mejor como se produce este tipo de problema:</p>

<p><img src="http://atasco.github.io/images/posts/unicast_asymmetric_routing.png" alt="Unicast Rutas Asimétricas" /></p>

<p>Vemos que inicialmente las tablas (ARP y CAM) en los switches (<em>core 1</em> y <em>core 2</em>) se encuentran vacías, el <em>host A</em> tiene el <em>core 1</em> como ruta por defecto y el <em>host B</em> tiene como ruta por defecto al <em>core 2</em>.</p>

<p><strong>[1]</strong> Imaginemos ahora que desde el <em>host A</em> se hace un ping al <em>host B</em>, enviando un paquete ICMP echo a través de su ruta de enlace, <em>core 1</em>. Como el <em>host A</em> desconoce la MAC de su gateway, envía en primer lugar un <em>ARP Request</em> para obtener la MAC de su IP (10.1.1.1).</p>

<p><img src="http://atasco.github.io/images/posts/unicast_asymmetric_routing_1.png" alt="Unicast Rutas Asimétricas: ICMP Echo" /></p>

<table>
<thead>
<tr>
<th align="left">host A (ARP)            </th>
<th align="center"> core 1 (CAM)           </th>
<th align="center"> core 1 (ARP)             </th>
<th align="center"> core 2 (ARP) </th>
<th align="center"> core 2 (CAM) </th>
<th align="right"> host B (ARP)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">10.1.1.1 0003.6bf1.2a01 </td>
<td align="center"> 0000.0c00.0001 1 Gi2/1 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center">              </td>
<td align="center">              </td>
<td></td>
</tr>
</tbody>
</table>


<p><strong>[2-3]</strong> El <em>core 1</em> desconoce la MAC del <em>host B</em>, de modo que envía un <em>ARP Request</em>. Cuando recibe el <em>ARP Replay</em> ambos <em>cores</em> aprenden el puerto origen del <em>host B</em>, con esta información el <em>core 1</em> enruta los paquetes al <em>core 2</em> a través de la <em>VLAN 2</em> (conoce la IP del <em>host B</em> y sabe que pertenece a la <em>VLAN 2</em>).</p>

<p><img src="http://atasco.github.io/images/posts/unicast_asymmetric_routing_2.png" alt="Unicast Rutas Asimétricas: Routing Core 1" /></p>

<table>
<thead>
<tr>
<th align="left">host A (ARP)            </th>
<th align="center"> core 1 (CAM)           </th>
<th align="center"> core 1 (ARP)             </th>
<th align="center"> core 2 (ARP) </th>
<th align="center"> core 2 (CAM)           </th>
<th align="right"> host B (ARP)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">10.1.1.1 0003.6bf1.2a01 </td>
<td align="center"> 0000.0c00.0001 1 Gi2/1 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center">              </td>
<td align="center"> 0000.0c00.0002 2 Gi2/1 </td>
<td align="right"> 10.1.2.1 0003.6bf1.2a01</td>
</tr>
<tr>
<td align="left">                        </td>
<td align="center"> 0000.0c00.0002 2 Gi1/1 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center">              </td>
<td align="center">                        </td>
<td align="right"> </td>
</tr>
</tbody>
</table>


<p><strong>[4]</strong> El <em>core 2</em> dispone de la información necesaria en su tabla CAM y entrega el <em>ICMP Echo Request</em> al <em>host B</em>.</p>

<p><img src="http://atasco.github.io/images/posts/unicast_asymmetric_routing_3.png" alt="Unicast Rutas Asimétricas: Entrega Host B" /></p>

<table>
<thead>
<tr>
<th align="left">host A (ARP)            </th>
<th align="center"> core 1 (CAM)           </th>
<th align="center"> core 1 (ARP)             </th>
<th align="center"> core 2 (ARP)             </th>
<th align="center"> core 2 (CAM)           </th>
<th align="right"> host B (ARP)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">10.1.1.1 0003.6bf1.2a01 </td>
<td align="center"> 0000.0c00.0001 1 Gi2/1 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center"> 0000.0c00.0002 2 Gi2/1 </td>
<td align="right"> 10.1.2.1 0003.6bf1.2a01</td>
</tr>
<tr>
<td align="left">                        </td>
<td align="center"> 0000.0c00.0002 2 Gi1/1 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center">                          </td>
<td align="center">                        </td>
<td align="right"> 10.1.2.2 0003.6bf1.2a02</td>
</tr>
</tbody>
</table>


<p><strong>[5]</strong> Ahora, el <em>host B</em> tiene que responder con un <em>ICMP Echo Replay</em> al <em>host A</em>. Como desconoce la MAC de su ruta por defecto envía un <em>ARP Request</em> a su gateway (10.1.2.2).</p>

<p><img src="http://atasco.github.io/images/posts/unicast_asymmetric_routing_replay.png" alt="Unicast Rutas Asimétricas: ICMP Reply" /></p>

<table>
<thead>
<tr>
<th align="left">host A (ARP)            </th>
<th align="center"> core 1 (CAM)           </th>
<th align="center"> core 1 (ARP)             </th>
<th align="center"> core 2 (ARP)             </th>
<th align="center"> core 2 (CAM)           </th>
<th align="right"> host B (ARP)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">10.1.1.1 0003.6bf1.2a01 </td>
<td align="center"> 0000.0c00.0001 1 Gi2/1 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center"> 0000.0c00.0002 2 Gi2/1 </td>
<td align="right"> 10.1.2.1 0003.6bf1.2a01</td>
</tr>
<tr>
<td align="left">                        </td>
<td align="center"> 0000.0c00.0002 2 Gi1/1 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center"> 0000.0c00.0001 1 Gi1/1 </td>
<td align="right"> 10.1.2.2 0003.6bf1.2a02</td>
</tr>
</tbody>
</table>


<p><strong>[6-7]</strong> Una vez que el <em>host B</em> envía el <em>Echo Replay</em> al <em>core 2</em> rellena con los datos su tabla ARP, pero como desconoce la MAC del <em>host A</em> envía un <em>ARP Request</em> a su IP (10.1.1.10). Con su respuesta agrega ese dato a sus tablas CAM y ARP, y enruta la respuesta al <em>core 2</em> a través de la VLAN 1.</p>

<table>
<thead>
<tr>
<th align="left">host A (ARP)            </th>
<th align="center"> core 1 (CAM)           </th>
<th align="center"> core 1 (ARP)             </th>
<th align="center"> core 2 (ARP)             </th>
<th align="center"> core 2 (CAM)           </th>
<th align="right"> host B (ARP)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">10.1.1.1 0003.6bf1.2a01 </td>
<td align="center"> 0000.0c00.0001 1 Gi2/1 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center"> 0000.0c00.0002 2 Gi2/1 </td>
<td align="right"> 10.1.2.1 0003.6bf1.2a01</td>
</tr>
<tr>
<td align="left">10.1.1.2 0003.6bf1.2a02 </td>
<td align="center"> 0000.0c00.0002 2 Gi1/1 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center"> 0000.0c00.0001 1 Gi1/1 </td>
<td align="right"> 10.1.2.2 0003.6bf1.2a02</td>
</tr>
</tbody>
</table>


<p><strong>[8]</strong> El <em>core 1</em> dispone de la información necesaria en su tabla CAM para entregar el <em>ICMP Echo Reply</em> al <em>host A</em>. La respuesta llega a su destino y se finaliza el flujo quedando las tablas de todos los elementos con los datos de IPs y MACs actualizados.</p>

<blockquote><p>El <em>host A</em> tiene como gateway el <em>core 1</em> en la VLAN 1 mientras que el <em>host B</em> tiene como gateway el <em>core 2</em> en la VLAN 2, es decir, existe una ruta asimétrica. La única manera de que el <em>core 1</em> aprenda la MAC del <em>host B</em>  es cuando el <em>host B</em> responde a un <em>ARP Request</em> del <em>core 1</em> (y al contrario con el <em>host A</em> y el <em>core 2</em>).</p></blockquote>

<p><strong>¿Qué ocurre cuando pasan cinco minutos?</strong></p>

<p>A los cinco minutos el <em>core 1</em> elimina de su tabla CAM las entradas de cuyas direcciones MAC no recibe tráfico, por lo que deja de conocer el puerto asociado a la MAC del <em>host B</em>. Como la tabla ARP no se vacía hasta que hayan transcurrido cuatro horas el <em>core 1</em> sigue conociendo la MAC asociada a la IP del <em>host B</em> (lo mismo ocurre con el <em>core 2</em> y el <em>host A</em>) y como resultado de esto el <em>core 1</em> tratará todo paquete con destino la MAC del <em>host B</em> como unicast (el <em>core 1</em> enviará el paquete con destino al <em>host B</em> a todos sus puertos produciéndose el <em>unicast flooding</em>).</p>

<table>
<thead>
<tr>
<th align="left">host A (ARP)            </th>
<th align="center"> core 1 (CAM)           </th>
<th align="center"> core 1 (ARP)             </th>
<th align="center"> core 2 (ARP)             </th>
<th align="center"> core 2 (CAM)           </th>
<th align="right"> host B (ARP)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">10.1.1.1 0003.6bf1.2a01 </td>
<td align="center"> 0000.0c00.0001 1 Gi2/1 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center"> 0000.0c00.0002 2 Gi2/1 </td>
<td align="right"> 10.1.2.1 0003.6bf1.2a01</td>
</tr>
<tr>
<td align="left">10.1.1.2 0003.6bf1.2a02 </td>
<td align="center">                        </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center">                        </td>
<td align="right"> 10.1.2.2 0003.6bf1.2a02</td>
</tr>
</tbody>
</table>


<h2>Cambios en la topología</h2>

<p>Hay eventos en la red que pueden provocar que la tabla CAM del switch se libere con una frecuencia mayor a la configurada (<em>aging time</em>), uno de estos eventos es el cambio de topología debido a STP, <em>Spanning Tree Protocol</em>.</p>

<p>Los cambios en la topología reducen el tiempo de las entradas en la tabla CAM de los 300 segundos habituales a 15 segundos en el caso del STP. En redes que hacen uso del RSTP, <em>Rapid Spanning Tree Protocol</em>, las direcciones MAC se liberan de la tabla CAM de forma inmediata.</p>

<p>En una red estable, los cambio de topología son pocos y se producen muy de vez en cuando. Las razones para que estos cambios tengan lugar son:</p>

<ul>
<li>Switches nuevos que se añaden a la red.</li>
<li>Eliminación de switches viejos.</li>
<li>Cambios de configuración realizados por el administrador.</li>
</ul>


<p>En estos casos, el cambio de topología es normal y necesario para el correcto funcionamiento de la red<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>.</p>

<p>Ahora bien, cuando se produce de forma continua tráfico unicast en una red estable es por la configuración incorrecta de los puertos asignados a los equipos (PCs, Hosts, Impresoras&hellip;). Estos equipos no participan en el proceso STP, por lo tanto los cambios de estado de sus interfaces de red (<em>LINK UP/LINK DOWN</em>) no deberían dar lugar a un cambio de topología STP<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup> y la forma de asegurarnos que esto sea así es utilizar la característica <em>PortFast</em> en la configuración de los puertos de los switches en los que están conectados estos equipos.</p>

<h2>Microsoft NLB</h2>

<p>Los cluster de Microsoft funcionan utilizando una IP virtual (VIP), que se asigna a la dirección MAC del cluster. El problema es que la dirección MAC del cluster no se utiliza para enviar tráfico, sino que este tráfico se cursa desde los nodos del mismo que tienen direcciones MAC distintas.<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup></p>

<p><img src="http://atasco.github.io/images/posts/microsoft_nlb.png" alt="Microsoft NLB" /></p>

<table>
<thead>
<tr>
<th align="center">switch (CAM)           </th>
<th align="center"> switch (ARP)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0d00.0d00.0d01 1 Fa0/1 </td>
<td align="center"> 192.168.1.1 0d00.0d00.0d01</td>
</tr>
<tr>
<td align="center">0000.00c0.0001 2 Fa0/2 </td>
<td align="center"> 10.1.1.1 0000.00c0.0001</td>
</tr>
<tr>
<td align="center">0000.00c0.0002 3 Fa0/3 </td>
<td align="center"> 10.1.1.2 0000.00c0.0002</td>
</tr>
</tbody>
</table>


<p>Como los switches no conocen en que puerto se encuentra la MAC del cluster (<em>10.1.1.111 &ndash; 03BF.0000.1111</em>, no hay un puerto físico del switch en la que se encuentra conectada), enviarán los paquetes a todos los puertos de la VLAN, resultando que todos los miembros del cluster recibirán el tráfico y el driver NBL en cada uno de los nodos determinará que nodo se hace cargo de la petición.</p>

<p>El problema es que todos los equipos en la misma VLAN también recibirán el tráfico destinado al cluster NBL ya que este tráfico se envía a todos los puertos.</p>

<h2>Teaming</h2>

<p>En aquellos casos en los que un host necesita enviar y/o recibir volumenes de tráfico muy elevados que no puede asumir un sólo enlace es necesario agrupar (<em>team, bond&hellip;</em>) más de un adaptador de red para aumentar el ancho de banda.</p>

<p>Al igual que en el host se agrupan los interfaces de red, el switch debe conocer que puertos pertenecen al mismo enlace lógico y realizar el ether-channel correspondiente con los mismos. De otra manera habrá problemas con entradas incorrectas en la CAM que darán lugar a la presencia de tráfico unicast.</p>

<h2>LLenado de la tabla CAM</h2>

<p>Cuando en una red hay una cantidad de host muy elevada, la tabla CAM puede llegar a llenarse. Si esto curre, el switch comenzará a enviar el trafico para aquellas direcciones que no tiene en la CAM a todos los puertos produciéndose el <em>unicast flooding</em>.</p>

<h1>Cómo detectarlo</h1>

<p>La forma más sencilla de detectar la presencia de tráfico unicast anómalo en la red es mediante la realización de capturas. Existen diversas herramientas para realizar estas capturas, siendo las más extendidas las que aparecen a continuación.</p>

<h2>TCPDUMP</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># Realizando las capturas desde el host 10.11.1.111 con MAC 00:19:99:57:5e:d5</span>
</span><span class='line'>tcpdump -i eth0 ether host not 00:19:99:57:5e:d5 and host not 10.11.1.111 and not broadcast and not multicast
</span></code></pre></td></tr></table></div></figure>


<h2>WIRESHARK</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># excluir tráfico multicast y broadcast</span>
</span><span class='line'>!<span class="o">(</span>eth.ig <span class="o">==</span> 1<span class="o">)</span>
</span><span class='line'><span class="c"># excluir mac del router - switch (xx.yy.zz.tt.uu.vv)</span>
</span><span class='line'>!<span class="o">(</span>eth.dst <span class="o">==</span> xx.yy.zz.tt.uu.vv<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h1>Soluciones</h1>

<h2>Rutas asimétricas</h2>

<p>Se pueden realizar cambios en la configuración de lo switches para remediar esta situación:</p>

<ul>
<li>Ajustando el periodo de permanencia de las entradas en la tabla CAM a 14400 segundos (aunque es mejor un valor más alto de 4 horas, por ejemplo 6).</li>
<li>Cambiar el tiempo de la tabla ARP a 5 minutos (300 segundos).</li>
<li>Cambiar los tiempos en ambas tablas (CAM y ARP) para que tengan el mismo valor (por ejemplo 10 minutos, 600 segundos)</li>
</ul>


<p>Usaremos preferentemente el método de cambiar el tiempo de permanencia en la tabla CAM a 14400 segundos (mejor 21600):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># CISCO IOS</span>
</span><span class='line'>core1<span class="o">(</span>config<span class="o">)</span><span class="c">#mac address-table aging-time [time in seconds] [vlan id]</span>
</span><span class='line'><span class="c"># CISCO CatOS</span>
</span><span class='line'>core1<span class="o">(</span>config<span class="o">)</span><span class="c">#set cam agingtime [vlan id] [time in seconds]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Cambios en la topología</h2>

<p>Es necesario identificar el puerto del switch causante del cambio, lo primero es determinar si ha ocurrido un cambio en la topología:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># CISCO IOS</span>
</span><span class='line'>core1#show mac-address table aging vlan <span class="o">[</span>vlan-id<span class="o">]</span>
</span><span class='line'><span class="c"># CISCO CatOS</span>
</span><span class='line'>core1#show cam agingtime <span class="o">[</span>vlan-id<span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Posteriormente identificamos el puerto causante del cambio:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># CISCO IOS</span>
</span><span class='line'>core1#show spantree-tree vlan <span class="o">[</span>vlan-id<span class="o">]</span> detail
</span><span class='line'><span class="c"># CISCO CatOS</span>
</span><span class='line'>core1#show spantree statistics <span class="o">[</span>mod/port<span class="o">]</span> <span class="o">[</span>vlan-id<span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Finalmente configuramos el puerto añadiendo:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># CISCO IOS</span>
</span><span class='line'>core1<span class="o">(</span>config-if<span class="o">)</span><span class="c">#spanning-tree port-fast</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Microsoft NLB</h2>

<p>No existe una solución válida y sencilla que nos permita evitar el <em>unicast flooding</em> cuando tenemos clusters NLB en la red. Una forma de mitigar el problema es crear una VLAN independiente para los nodos del clúster.</p>

<p>Ahora bien, en el caso de tener un NLB en modo multicast, existe la posibilidad de evitar el tráfico unicast añadiendo de forma estática en las tablas ARP y CAM las IP y MAC asociadas a la IP virtual del clúster.</p>

<p>Por ejemplo, si la IP virtual es la 10.10.10.10 y la MAC 1111.1111.1111 en la VLAN 100 donde los nodos del clúster están conectados a los puertos Gi0/1 y Gi0/2:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># ROUTER</span>
</span><span class='line'>core1#conf t
</span><span class='line'>core1#arp 10.10.10.10 1111.1111.1111 ARPA
</span><span class='line'><span class="c"># SWITCH</span>
</span><span class='line'>core1#conf t
</span><span class='line'>core1#mac-address-table static 1111.1111.1111 vlan 100 int gi0/1 gi0/2
</span></code></pre></td></tr></table></div></figure>


<h2>Teaming</h2>

<p>La manera de evitar el <em>unicast flooding</em> cuando hay host en la red con interfaces agrupados es verificar y realizar una configuración correcta del team (bond) en el lado del host y del ether-channel en el switch, asegurando el que el protocolo utilizado y los puertos agregados son los correctos.</p>

<h2>LLenado de la tabla CAM</h2>

<p>En este caso, la solución consiste en segmentar la red en subredes (VLAN) más pequeñas.</p>

<h1>Referencias</h1>

<p><a href="http://www.cisco.com/en/US/products/hw/switches/ps700/products_tech_note09186a00801d0808.shtml">Unicast Flooding in Switched Campus Networks</a></p>

<p><a href="http://www.cisco.com/en/US/tech/tk648/tk362/technologies_tech_note09186a0080094afd.shtml#t8">Understanding and Troubleshooting HSRP Problems in Catalyst Switch Networks</a></p>

<p><a href="http://www.cisco.com/en/US/products/hw/switches/ps708/products_tech_note09186a00807347ab.shtml">Catalyst 6500/6000 Switches ARP or CAM Table Issues Troubleshooting</a></p>

<p><a href="http://www.ciscozine.com/2012/04/15/unicast-flooding-due-to-asymmetric-routing/">Unicast flooding due to asymmetric routing</a></p>

<p><a href="http://www.ciscopress.com/articles/article.asp?p=336872">Troubleshooting Unicast Flooding Due to Topology</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Los switches almacenan en tablas dinámicas (content addressable memory table, CAM table) las relaciones entre puertos y MACs. Estas tablas tienen un periodo de vida (timeout) determinado (en el caso de switches cisco, por defecto son 5 minutos) y un tamaño tambien limitado.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Las MAC puede pasar a estar inactivas debido a que el dispositivo se encuentra apagado o bien a que los equipos se han conectado a otro puerto distinto del switch.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Este tráfico unicast es normal en la red y no supone un riesgo para la misma.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>En realidad son tres, también esta la tabla TCAM (Ternary Content Addressable Memory), pero no es necesaria para entender el comportamiento del <em>unicast flooding</em>.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Cuando un <strong>host B</strong> quiere enviar información a un <strong>host A</strong> y no tiene en su tabla ARP la direccion MAC del <strong>host A</strong>, el <strong>host B</strong> genera un mensaje de broadcast que llega a todos los host del dominio de broadcast (ARP Request) en el que se encuentra para obtener la dirección MAC asociada a la IP del <strong>host A</strong>. Sólo el <strong>host A</strong> responde al mensaje con su dirección MAC.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>A medida que los paquetes llegan a los puertos del switch este aprende la dirección MAC que se encuentra detrás de los mismos y los guarda en la tabla CAM. En la tabla CAM se registra la dirección MAC, el puerto, la VLAN y el timestamp. Si la dirección MAC aprendida por un switch en un puerto se mueve a otro puerto diferente, la dirección MAC y el timestamp se registran para el último puerto y la entrada previa se borra. Si la dirección MAC se encuentra registrada en la tabla CAM en el mismo puerto, únicamente se actualiza el timestamp en la entrada existente.<a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
<li id="fn:7">
<p>Las notificaciones de cambio de topología (<em>TCN</em>) están diseñadas para corregir la tablas de reenvío cuando se produce un cambio. Esto es necesario para evitar cortes en las comunicaciones, ya que cuando se produce un cambio de topología algunos destinos dejan de estar accesibles a través de unos determinados puertos para ser accesibles por otros. TCN funciona reduciendo el tiempo de permanencia de las entradas en la tabla CAM, de modo que si una dirección no se vuelve a aprender se eliminará de la tabla y se producirá el envío de tráfico unicast por todos los puertos del switch.<a href="#fnref:7" rev="footnote">&#8617;</a></p></li>
<li id="fn:8">
<p>Los puertos del switch asignados a los host no están involucrados en los cambios de topología STP o en el envío de las BPDUs.<a href="#fnref:8" rev="footnote">&#8617;</a></p></li>
<li id="fn:9">
<p>Es más complejo que todo todo esto, en función de como se configura el cluster NLB (multicast o unicast) el comportamiento del tráfico varía.<a href="#fnref:9" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Parcheando ESXi 5.X sin VUM]]></title>
    <link href="http://atasco.github.io/blog/2013/11/28/parcheando-esxi-sin-vum/"/>
    <updated>2013-11-28T18:30:00+01:00</updated>
    <id>http://atasco.github.io/blog/2013/11/28/parcheando-esxi-sin-vum</id>
    <content type="html"><![CDATA[<p>En ocasiones, aplicar parches a los servidores <strong>ESXi 5.X</strong> no es sencillo cuando no se dispone de un vCenter (con vSphere Update Manager, VUM), tal como ocurre en los entornos de laboratorio formados por ESXi independientes.</p>

<p>Vamos a ver como es posible aplicar los parches a los servidores ESXi de manera sencilla siguiendo los pasos siguientes.</p>

<!-- more -->


<h2>Requisito previo</h2>

<p>Es necesario tener acceso vía SSH al servidor, para habilitarlo tenemos dos opciones:</p>

<h3>A través del vSphere Client</h3>

<ol>
<li>Abrimos sesión en el servidor ESXi con el cliente</li>
<li>Seleccionamos la pestaña <em>Configuration</em> y pinchamos en <em>Security Profile</em></li>
<li>Pinchar en <em>Properties</em> en la esquina superior derecha y seleccionar el servicio <em>SSH</em> pulsando el botón <em>Options</em></li>
<li>Desde aqui se puede arrancar el servicio y seleccionar las opciones de arranque del mismo</li>
</ol>


<h3>A través de la consola del servidor ESXi</h3>

<ol>
<li>Pulsar <em>F2</em> para acceder al menu de configuración</li>
<li>Seleccionar <em>Troubleshooting Options</em></li>
<li>Desde el menu de opciones seleccionar <em>Enable SSH</em></li>
</ol>


<h2>Dejar los parches en un Datastore accesible desde el servidor ESXi</h2>

<p>Una vez que se descargan los parches desde la <a href="http://www.vmware.com/patch/download">web de vmware</a>, hay que dejarlos accesibles al servidor ESXi donde se van a aplicar.</p>

<blockquote><p>Es conveniente crear una carpeta en el datastore para dejarlos y poder aplicarlos posteriormente.</p></blockquote>

<h2>Aplicar los parches</h2>

<p>Antes de aplicar los parches hay que apagar de forma ordenada todas las máquinas virtuales que están en el servidor.</p>

<p>Conectarse por SSH al servidor ESXi y aplicar los parches mediante el comando:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>esxcli software vib update /vmfs/volumes/parches/&lt;your-upgrade-bundle.zip></span></code></pre></td></tr></table></div></figure>


<p>Una vez que finaliza la aplicación del parche, aparecerá un mensaje indicándolo y solicitando el reinicio del servidor.</p>

<h2>Referencias</h2>

<p><a href="http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=2004746">Using ESXi Shell in ESXi 5.0 and 5.1</a></p>

<p><a href="http://communities.vmware.com/thread/328758">How to patch ESXi 5 en VMWare Communities</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Odio las LUNes!]]></title>
    <link href="http://atasco.github.io/blog/2013/09/08/odio-las-lunes/"/>
    <updated>2013-09-08T20:30:00+02:00</updated>
    <id>http://atasco.github.io/blog/2013/09/08/odio-las-lunes</id>
    <content type="html"><![CDATA[<p>Julio y agosto, meses de vacaciones, momento ideal para <em>romper</em> la infraestructura virtual con las actualizaciones anuales. Este año toca <strong>vSpehere 5.1</strong> (si esperamos un poco caemos en la 5.5).</p>

<p>Tras la pertinente revisión de compatibilidad de hardware y la toma de decisiones previas (que implican cambio del vCenter, nos pasamos al nuevo appliance bajo LiNUX <a href="http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=2007619">VCSA</a>, asignación de nuevas LUN…) se procede a la instalación del nuevo vCenter y la migración de los ESX 4.1 U2.</p>

<!-- more -->


<p><strong>¡Sorpresa!</strong> Al disponer de diferente hardware no es posible actualizar a 5.1 parte de los blades HP BL460c (los G1) que forman parte de la infraestructura, por lo que se decide mantener un entorno mixto con servidores ESXi 5.0 y 5.1.</p>

<p>Esto supone reconsiderar la planificación inicial y separar los ESXi por versión en dos cluster (planificado inicialmente para mantener dos entornos independientes, uno para servidores de desarrollo y otro para los de producción) en vez de mantener un único cluster con un pool de recursos dedicado a las VM de desarrollo.</p>

<p>Una vez realizada la migración, se observa que el rendimiento en acceso a disco de las VM en los ESXi 5.0 no se corresponde con las VM en los ESXi 5.1.</p>

<p>Revisando la configuración se observa que la politica de selección de caminos en las LUNes de la cabina (EMC VNX 5500 que soporta el protocolo ALUA) para los ESXi 5.0 no es la que tenemos configurada habitualmente. Aparece como FIXED cuando debería estar como ROUND ROBIN.</p>

<p>Con el comando:</p>

<blockquote><p>esxcli storage nmp satp list</p></blockquote>

<p>Obtenemos la política de selección de caminos (PSP) actual.</p>

<p>Por ejemplo, en un ESXi 5.0:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>Name                 Default PSP    Description
</span><span class='line'>-------------------  -------------  -------------------------------------------------------
</span><span class='line'>VMW_SATP_ALUA_CX     VMW_PSP_FIXED  Supports EMC CX that use the ALUA protocol
</span><span class='line'>VMW_SATP_ALUA        VMW_PSP_MRU    Supports non-specific arrays that use the ALUA protocol
</span><span class='line'>VMW_SATP_CX          VMW_PSP_MRU    Supports EMC CX that <span class="k">do </span>not use the ALUA protocol
</span><span class='line'>VMW_SATP_MSA         VMW_PSP_MRU    Placeholder <span class="o">(</span>plugin not loaded<span class="o">)</span>
</span><span class='line'>VMW_SATP_DEFAULT_AP  VMW_PSP_MRU    Placeholder <span class="o">(</span>plugin not loaded<span class="o">)</span>
</span><span class='line'>...
</span></code></pre></td></tr></table></div></figure>


<p>Cambiar la PSP por defecto es sencillo, solo hay que ejecutar el comando:</p>

<blockquote><p>esxcli storage nmp satp set &mdash;default-psp=policy &mdash;satp=your_SATP_name</p></blockquote>

<p>Para cambiar el modo FIXED por ROUND ROBIN en la cabina VNX 3000 que soporta ALUA, el comando a ejecutar es:</p>

<blockquote><p>esxcli storage nmp satp set &mdash;default-psp=VMW_PSP_RR &mdash;satp=VMW_SATP_ALUA_CX</p></blockquote>

<p>A partir de ahora las nuevas LUN de la cabina que se presenten a los ESXi 5.0 tendrán como PSP Round Robin, pero las que se encuentran ya presentadas mantendrán la política Fixed.</p>

<p>Se puede cambiar la politica selección de camino reiniciando el ESXi para hacerlo de forma global para todas las LUN que se presebtan al mismo, o bien de forma individual para cada LUN.</p>

<p>Para conseguir que una LUN pase a utilizar un PSP diferente, ejecutamos el comando siguiente en el ESXi afectado:</p>

<blockquote><p>esxcli storage nmp device set -d NAAID -psp=policy</p></blockquote>

<p>Es necesario identificar previamente el NAAID de la LUN afectada. Para ello se puede hacer uso del cliente gráfico (viclient o web) o con el comando:</p>

<blockquote><p>esxcli storage nmp device list</p></blockquote>

<p>Una vez realizado el cambio se verifica el mismo con:</p>

<blockquote><p>esxcli storage nmp device list -d NAAID</p></blockquote>

<p>Ejemplo:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>esxcli storage nmp device <span class="nb">set</span> -d naa.6006016055711d00cff95e65664ee011 --psp<span class="o">=</span>VMW_PSP_MRU
</span></code></pre></td></tr></table></div></figure>


<p>Una vez realizados los cambios, con todos los ESXi utilizando la misma política de selección de caminos para las LUNes, el rendimiento de los hosts con versión 5.0 se estabiliza y adquiere valores similares a los que tienen la versión 5.1.</p>

<h2>Resumen</h2>

<h3>Cambio de la PSP por defecto</h3>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># Mirar la PSP (Path Selection Policy)actual</span>
</span><span class='line'>esxcli storage nmp satp list
</span><span class='line'><span class="c"># Cambiar la PSP por defecto</span>
</span><span class='line'>esxcli storage nmp satp <span class="nb">set</span> --default-psp<span class="o">=</span>policy --satp<span class="o">=</span>your_SATP_name
</span><span class='line'><span class="c"># Verificar el cambio</span>
</span><span class='line'>esxcli storage nmp satp list
</span></code></pre></td></tr></table></div></figure>


<h3>Cambio de la PSP por LUN</h3>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># Identificar LUN ID (NAA ID)</span>
</span><span class='line'><span class="c"># 1. En VI Client (o web).</span>
</span><span class='line'><span class="c"># 2. Vía comando</span>
</span><span class='line'>esxcli storage nmp device list
</span><span class='line'><span class="c"># Cambiar la PSP</span>
</span><span class='line'>esxcli storage nmp device <span class="nb">set</span> -d NAAID -psp<span class="o">=</span>policy
</span><span class='line'><span class="c"># Verificar el cambio</span>
</span><span class='line'>esxcli storage nmp device list -d NAAID
</span></code></pre></td></tr></table></div></figure>


<h2>Referencias</h2>

<p><a href="http://kb.vmware.com/selfservice/search.do?cmd=displayKC&amp;docType=kc&amp;docTypeID=DT_KB_1_1&amp;externalId=1017760">Changing the default pathing policy for new/existing LUNs</a></p>

<p><a href="http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=1036189">Changing a LUN to use a different Path Selection Policy</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cómo se hizo]]></title>
    <link href="http://atasco.github.io/blog/2013/07/14/como-se-hizo/"/>
    <updated>2013-07-14T18:30:00+02:00</updated>
    <id>http://atasco.github.io/blog/2013/07/14/como-se-hizo</id>
    <content type="html"><![CDATA[<p>En la actualidad crear un blog, partiendo de unos conocimientos básicos, es relativamente sencillo. Existen diversas herramientas que facilitan la tarea, de modo que lo más complicado es elegir la que se adapte a las necesiades de cada uno.</p>

<p>En <strong>atas.co</strong> la herramienta utilizada es <a href="http://octopress.org">octopress</a> con el tema <a href="http://alexgaribay.com">octoflat</a> y utilizando como hosting <a href="http://pages.github.com">Github Pages</a>.</p>

<!-- more -->


<p>La documentación de octopress es muy completa y clara, siguiéndola es muy sencillo crear y desplegar un blog con esta herramienta. Además, existen múltiples blogs<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> donde los usuarios han detallado paso a paso como hacer la instalación así que no voy a repetir aquí aquello que ya esta escrito en otros lugares.</p>

<p>Si que voy a recoger en esta entrada aquellas fuentes que han facilitado (y que posiblemente sin ellas este mismo post no existiría) la creación de <strong>atas.co</strong>. Además de la <a href="http://octopress.org/docs/">documentación de octopress</a>, la información que se recoge en las siguientes webs me ha resultado muy útil para poner en marcha este proyecto.</p>

<ul>
<li><a href="http://www.moncefbelyamani.com/how-to-install-and-configure-octopress-on-a-mac/">How to Install &amp; Configure Octopress on a Mac, and Host Your Static Website on Amazon S3</a></li>
<li><a href="http://codeloveandboards.com/blog/2013/01/24/desplegando-tu-blog-octopress-en-github-pages/">Desplegando tu blog Octopress en GitHub Pages</a></li>
</ul>


<p>Una vez que tenemos el blog operativo con <strong>octopress</strong>, si el contenido está en español como es el caso, tenemos el &ldquo;pequeño&rdquo; inconveniente de que las fechas aparecen automáticamente en perfecto inglés. La solución es sencilla si seguimos las instrucciones que aparecen en <a href="http://www.hazteonline.es/blog/press/2012/08/17/las-fechas-en-octopress/">las fechas en octopress</a>.</p>

<p>Gracias a toda esta información desplegar el blog no ha supuesto mucho esfuerzo, y si yo he podido hacerlo cualquiera es capaz :)</p>

<h2>Actualización: 14/12/2013</h2>

<p>Preparando una nueva entrada repleta de tablas, me he dado cuenta que las tablas en octopress no se generan de forma correcta, ya que no presentan los bordes correspondientes.</p>

<p>La solución a este <em>&ldquo;problemilla&rdquo;</em> se puede encontrar en <a href="http://samwize.com/2012/09/24/octopress-table-stylesheet/">Octopress Table Stylesheet</a>.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Una búsqueda en google devuelve una cantidad importante de resultados. <a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Luces, Cámara, Acción!]]></title>
    <link href="http://atasco.github.io/blog/2013/06/11/luces-camara-accion/"/>
    <updated>2013-06-11T22:44:00+02:00</updated>
    <id>http://atasco.github.io/blog/2013/06/11/luces-camara-accion</id>
    <content type="html"><![CDATA[<p> <img class="left" src="http://atasco.github.io/images/posts/lca.jpg" title="'Luces, Cámara, Acción'" ></p>

<p><strong><em>El personal se ubica en sus puestos y todo está listo para comenzar el rodaje.</em></strong></p>

<p>Como en toda buena cinta lo importantes es un buen guión, con un planteamiento interesante seguido de un nudo que no deje que el &ldquo;espectador&rdquo; aparte la vista de la pantalla y un final redondo que cierre todas las incognitas planteadas durante el desarrollo.</p>

<!-- more -->


<p>Siguiendo con la analogía cinéfila, la historia que en  <strong>atas.co</strong> se va a desarrollar presenta las siguientes características:</p>

<ul>
<li><p><strong>Planteamiento:</strong> El protagonista se enfrenta a la adversidad. La situación es nueva, desconocida y desconcertante.</p>

<blockquote><p>Marrón de proporciones biblicas se presenta en el horizonte (problemón relacionado con estos malditos cacharros llamados sistemas operativos, servidores, redes, virtualización…). Y por supuesto hay que tener una solución al problema <em>ya mismo</em>.</p></blockquote></li>
<li><p><strong>Nudo:</strong> La lucha para salir del atolladero es titánica llevando al protagonista a enfrentarse a la situación sin desfallecer hasta que con ayuda del resto de personajes logra superar la prueba.</p>

<blockquote><p>Comienza la lectura de documentación, los foros, los recuerdos de problemas previos que <em>se parecen un poco</em>.</p></blockquote></li>
<li><p><strong>Desenlace:</strong> Después de aventuras sin fin, el protagonista sale airoso llevandose de paso a esa chica tan guapa que le ha ayudado en la aventura.</p>

<blockquote><p>Después de numerosos ensayos de prueba y error la solución al problema aparece milagrosamente. Hay que registrar cuidadosamente los pasos seguidos para que cuando se repita la situación (que no lo dudéis se repetirá) podamos tener esa guía que nos saque del <strong>atas.co</strong></p></blockquote></li>
</ul>


<p>Además de esta línea argumental, también tendremos subtramas con sus respectivos nudos y desenlaces&hellip;</p>

<p><strong><em>Ahora solo queda seguir mirando y descubrir si la película será un thriller, una comedia, tal vez un drama o una historia sangrienta de terror.</em></strong></p>
]]></content>
  </entry>
  
</feed>
