<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Categoría: network | a t a s c o]]></title>
  <link href="http://atasco.github.io/blog/categories/network/atom.xml" rel="self"/>
  <link href="http://atasco.github.io/"/>
  <updated>2014-10-26T21:23:00+01:00</updated>
  <id>http://atasco.github.io/</id>
  <author>
    <name><![CDATA[aH]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Análisis: Air Console]]></title>
    <link href="http://atasco.github.io/blog/2014/10/26/analisis-air-console/"/>
    <updated>2014-10-26T21:30:00+01:00</updated>
    <id>http://atasco.github.io/blog/2014/10/26/analisis-air-console</id>
    <content type="html"><![CDATA[<p>{% img right /images/posts/airconsole.png &lsquo;airconsole&rsquo; %}</p>

<p>Una tarea tan común y aparentemente sencilla, que todo ingeniero de redes realiza de forma continua, como es conectarse vía consola a la electrónica de red (router, switch, firewall&hellip;) puede complicarse si el acceso al dispositivo no resulta sencillo.</p>

<p>Para esos casos el dispositivo que analizamos en esta entrada puede ser la solución ideal.</p>

<!-- more -->


<p>En ocasiones trabajar en un <a href="http://es.wikipedia.org/wiki/Centro_de_procesamiento_de_datos">CPD</a> puede resultar una experiencia incomoda por el espacio de trabajo que disponemos y/o por las condiciones de temperatura. En otras situaciones, el acceso a los armarios de comunicaciones resulta casi una misión imposible por el lugar donde están ubicados y conectarse a la consola de los switches, routers&hellip; <em>colgado</em> no es lo más adecuado.</p>

<p>Si a todo esto le añadimos que cada vez utilizamos más dispositivos móviles (smartphones, tablets&hellip;), que pueden llegar a sustituir a los ordenadores portátiles, resulta muy práctico disponer de un dispositivo que nos facilite el acceso a la consola haciendo uso de los mismos. <a href="http://www.get-console.com/airconsole/">Air Console</a> es la solución a todos estos inconvenientes.</p>

<p>Se trata de un producto originario de Nueva Zelanda, pero la compra y el envío ha resultado de lo más rápido y sencillo. Realizando el pedido a través de la <a href="http://www.get-console.com/shop/">tienda online</a> un domingo, el miércoles ya estaba el producto en su destino.</p>

<p>Una vez desembalado, y cargada la batería, lo primero es su configuración. En la caja del producto viene una <a href="http://www.get-console.com/airconsole/files/Airconsole-QuickStart-Wifi-Bluetooth-2.5.pdf">guía rápida</a> que resulta suficiente para los primeros pasos.</p>

<p><strong>Air Console</strong> se conecta a la consola del dispositivo y a su vez se comporta como un <a href="http://es.wikipedia.org/wiki/Punto_de_acceso_inal%C3%A1mbrico">AP</a> al que nos podemos conectar, se trata de un adaptador <a href="http://es.wikipedia.org/wiki/RS-232">RS232</a> sobre wifi y bluetooth.</p>

<p>Para acceder a la consola desde dispositivos móviles, <strong>Get Console</strong> dispone de aplicaciones para <a href="http://es.wikipedia.org/wiki/Android">Android</a> (<a href="https://play.google.com/store/apps/details?id=nz.co.cloudstore.serialbot">SerialBot</a>) y para <a href="http://es.wikipedia.org/wiki/IOS">iOS</a> (<a href="https://itunes.apple.com/us/app/rapidssh/id546150309?mt=8">RapidSSH</a>, <a href="https://itunes.apple.com/us/app/get-console/id412067943?mt=8&amp;ls=1">Get Console</a>).</p>

<p>Para los sistemas operativos Windows y Mac OS X, en la propia web de <strong>Get Console</strong> están disponibles los drivers correspondientes.</p>

<p>En caso de utilizar otro sistema operativo, tenemos las siguientes opciones:</p>

<ol>
<li><p>Se puede usar el navegador web del dispositivo para conectarse al emulador de terminal (<a href="http://es.wikipedia.org/wiki/VT100">VT100</a>) que facilita como puente <strong>Air Console</strong>. Sólo hay que conectarse a <code>http://&lt;IP_AIRCONSOLE&gt;/terminal.asp</code>.</p></li>
<li><p>Se puede usar un <a href="http://es.wikipedia.org/wiki/Emulador_de_terminal">emulador de terminal</a> en el dispositivo para conectarse vía <a href="http://es.wikipedia.org/wiki/Telnet">telnet</a> al puerto 3696 (2167 para serial raw) de <strong>Air Console</strong>.</p></li>
<li><p>También se puede usar un cliente <a href="http://es.wikipedia.org/wiki/WebSocket">websockets</a> para conectarse a <strong>Airconsole</strong>.</p></li>
<li><p>Finalmente, si la programación es lo tuyo, puedes escribir una aplicación para interactuar con <strong>Air Console</strong> utilizando los <a href="http://es.wikipedia.org/wiki/Kit_de_desarrollo_de_software">SDKs</a> disponibles en <a href="http://www.get-console.com">Get Console</a>.</p></li>
</ol>


<p>Si usas LiNUX, lo mas sencillo es crear un nuevo dispositivo con <strong>socat</strong>:</p>

<p><code>sh
socat PTY,link=/dev/ttyVS0,user=root,group=uucp,mode=660 TCP:&lt;IP_AIRCONSOLE&gt;:3696
</code></p>

<p>Ahora solo hemos de usar <a href="http://atas.co/blog/2014/06/18/screen-la-pantalla-indiscreta/">screen</a> para conectarnos a través del nuevo dispositivo serie virtual creado con <strong>socat</strong>:</p>

<p><code>sh
screen /dev/ttyVS0
</code></p>

<h1>Referencias</h1>

<p><a href="http://www.get-console.com/airconsole/">Air Console</a></p>

<p><a href="http://www.dest-unreach.org/socat/">Socat</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Enlaces troncales Cisco Catalyst - ESX(i)]]></title>
    <link href="http://atasco.github.io/blog/2014/09/20/enlace-troncal-esx-cisco/"/>
    <updated>2014-09-20T20:40:00+02:00</updated>
    <id>http://atasco.github.io/blog/2014/09/20/enlace-troncal-esx-cisco</id>
    <content type="html"><![CDATA[<p>Para realizar la instalación de un servidor ESX(i) en la infraestructura virtual es preciso hacer un análisis previo que nos permita determinar las necesidades. Dentro de estas necesidades la conexión del nuevo servidor en la red es una de las más críticas e importantes.</p>

<p>Existe mucha documentación al respecto en la <a href="http://kb.vmware.com/selfservice/microsites/">base de datos de conocimiento de VMWare</a> así como en sus <a href="https://communities.vmware.com/community">comunidades</a>, pero en este artículo vamos a centrarnos en la conexión del servidor ESX(i) con los switches (Cisco) desplegados en la red.</p>

<!-- more -->


<p>Antes de comenzar con los comandos para la configuración de los switches físico (Cisco Catalyst) y virtual (VMWare vSwitch0), vamos a ver en el siguiente diagrama el diseño final que queremos alcanzar.</p>

<p><img src="/images/posts/trunk_cisco_esx_1.png" alt="Diagrama de conexión Cisco - ESX" /></p>

<table>
<thead>
<tr>
<th align="left">VLAN </th>
<th> Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">60   </td>
<td> Red de Gestión (<strong>management network</strong>)</td>
</tr>
<tr>
<td align="left">70   </td>
<td> Red de VMotion (<strong>VMotion network</strong>)</td>
</tr>
</tbody>
</table>


<h1>Configuración Cisco Catalyst</h1>

<p>En primer lugar configuramos los puertos que intervienen en el <em>EtherChannel</em>:</p>

<p><code>
enable
configure terminal
interface GigabitEthernet1/1
description ESX_LAB-NIC0
channel-group 1 mode on
interface GigabitEthernet1/2
description ESX_LAB-NIC1
channel-group 1 mode on
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>Comando <code>configure terminal</code>: entramos en modo configuración.</li>
<li>Comando <code>interface GigabitEthernet1/1</code>: puerto del switch que vamos a configurar.</li>
<li>Comando <code>description ESX_LAB-NIC0</code>: descripción del puerto.</li>
<li>Comando <code>channel-group 1 mode on</code>: asignamos el puerto al grupo 1 y configuramos el modo incondicional.</li>
</ul>


<p>Ahora pasamos a configurar la interfaz lógica, <em>Port-Channel</em>, asociada a la agrupación de puertos del <em>EtherChannel</em>:</p>

<p><code>
enable
configure terminal
interface port-channel 1
witchport trunk encapsulation dot1q
switchport trunk allowed vlan 60,70
switchport mode trunk
switchport nonegotiate
spanning-tree portfast trunk
</code></p>

<ul>
<li>Comando <code>interface port-channel 1</code>: Port-Channel que vamos a configurar.</li>
<li>Comando <code>switchport trunk encapsulation dot1q</code>: configuramos como protocolo de encapsulación el estándard del IEEE 802.1q (dot1q) ya que los ESX(i) sólo soportan este protocolo.</li>
<li>Comando <code>switchport trunk allowed vlan 60,70</code>: configuramos las VLANs permitidas en el enlace troncal.</li>
<li>Comando <code>switchport mode trunk</code>: habilitamos el enlace troncal.</li>
<li>Comando <code>switchport nonegotiate</code>: como ESX(i) no soporta DTP (Dynamic Trunking Protocol) lo deshabilitamos.</li>
<li>Comando <code>spanning-tree portfast trunk</code>: habilitamos PortFast en el interface cuando se encuentra en modo troncal.</li>
</ul>


<p>Finalmente verificamos la configuración y grabamos los cambios:</p>

<p><code>
show interfaces trunk
show etherchannel summary
copy running-config startup-config
</code></p>

<blockquote><p>Cuando el vSwitch del servidor no está configurado y tenemos varios puertos en el <em>EtherChannel</em> activos no es posible llegar en remoto a la red de gestión (<strong>management network</strong>), para lograrlo lo más sencillo es dejar sólo un puerto del <em>EtherChannel</em> activo.</p></blockquote>

<h1>Configuración vSwitch0 ESX(i)</h1>

<p>Si el nuevo ESX(i) va a formar parte de una infraestructura virtual previa donde ya hay desplegado un vCenter, podemos realizar la configuración del virtual switch a través del <strong>web client</strong>:</p>

<p><img src="/images/posts/vswitch_vcenter.png" alt="vSwitch - ESX" /></p>

<ol>
<li>Cambiamos la configuración de balanceo a <code>Route based on IP hash</code>.</li>
<li>Ponemos activos los adaptadores (vmnic) que están en <strong>standby</strong>.</li>
</ol>


<p>Si no existe un VCenter o si nos encontramos más cómodos con el <em>cli</em>, podemos configurar el switch virtual a través de la línea de comandos, accediendo vía SSH al servidor ESX(i):</p>

<p><code>
esxcfg-vswitch -v 60 -p "Management Network" vSwitch0
</code></p>

<h1>Referencias</h1>

<p><a href="http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=1006628">Sample switch port configuration for VLAN and TRUNK MODE</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Enlaces troncales Cisco Catalyst - ESX(i)]]></title>
    <link href="http://atasco.github.io/blog/2014/09/20/enlace-troncal-esx-cisco/"/>
    <updated>2014-09-20T20:40:00+02:00</updated>
    <id>http://atasco.github.io/blog/2014/09/20/enlace-troncal-esx-cisco</id>
    <content type="html"><![CDATA[<p>Antes de realizar la instalación de un servidor ESX(i) en la infraestructura virtual es preciso hacer un análisis previo para determinar las necesidades. Dentro de estás necesidades la conexión del nuevo servidor en la red es una de las más críticas e importantes.</p>

<p>Existe mucha documentación al respecto en la <a href="http://kb.vmware.com/selfservice/microsites/">base de datos de conocimiento de VMWare</a> así como en sus <a href="https://communities.vmware.com/community">comunidades</a>, pero en este artículo vamos a centrarnos en la conexión del servidor ESX(i) con los switches (Cisco) desplegados en la red.</p>

<!-- more -->


<p>Antes de comenzar con los comandos para la configuración de los switches físico (Cisco Catalyst) y virtual (VMWare vSwitch0), vamos a ver en el siguiente diagrama el diseño final que queremos alcanzar.</p>

<p><img src="/images/posts/trunk_cisco_esx_1.png" alt="Diagrama de conexión Cisco - ESX" /></p>

<table>
<thead>
<tr>
<th align="left">VLAN </th>
<th> Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">60   </td>
<td> Red de Gestión (<strong>management network</strong>)</td>
</tr>
<tr>
<td align="left">70   </td>
<td> Red de VMotion (<strong>VMotion network</strong>)</td>
</tr>
</tbody>
</table>


<h1>Configuración Cisco Catalyst</h1>

<p>Configuramos los puertos que intervienen en el EtherChannel.</p>

<p><code>
enable
configure terminal
interface GigabitEthernet1/1
description ESX_LAB-NIC0
channel-group 1 mode on
interface GigabitEthernet1/2
description ESX_LAB-NIC1
channel-group 1 mode on
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>Comando <code>configure terminal</code>: entramos en modo configuración.</li>
<li>Comando <code>interface GigabitEthernet1/1</code>: puerto del switch que vamos a configurar.</li>
<li>Comando <code>description ESX_LAB-NIC0</code>: descripción del puerto.</li>
<li>Comando <code>channel-group 1 mode on</code>: asignamos el puerto al grupo 1 y configuramos el modo incondicional.</li>
</ul>


<p>Configuramos la interfaz lógica, Port-Channel, asociada a la agrupación de puertos del EtherChannel:</p>

<p><code>
enable
configure terminal
interface port-channel 1
witchport trunk encapsulation dot1q
switchport trunk allowed vlan 60,70
switchport mode trunk
switchport nonegotiate
spanning-tree portfast trunk
</code></p>

<ul>
<li>Comando <code>interface port-channel 1</code>: Port-Channel que vamos a configurar.</li>
<li>Comando <code>switchport trunk encapsulation dot1q</code>: configuramos como protocolo de encapsulación el estándard del IEEE 802.1q (dot1q) ya que los ESX(i) sólo soportan este protocolo.</li>
<li>Comando <code>switchport trunk allowed vlan 60,70</code>: configuramos las VLANs permitidas en el enlace troncal.</li>
<li>Comando <code>switchport mode trunk</code>: habilitamos el enlace troncal.</li>
<li>Comando <code>switchport nonegotiate</code>: como ESX(i) no soporta DTP (Dynamic Trunking Protocol) lo deshabilitamos.</li>
<li>Comando <code>spanning-tree portfast trunk</code>: habilitamos PortFast en el interface cuando se encuentra en modo troncal.</li>
</ul>


<p>Verificamos la configuración y grabamos los cambios:</p>

<p><code>
show interfaces trunk
show etherchannel summary
copy running-config startup-config
</code></p>

<blockquote><p>En un primer momento, cuando el vSwitch del servidor no está configurado, si tenemos varios puertos en el EtherChannel activos no es posible llegar en remoto a la red de gestión (<strong>management network</strong>). Para lograrlo lo más sencillo es dejar sólo un puerto del EtherChannel activo.</p></blockquote>

<h1>Configuración vSwitch0 ESX(i)</h1>

<p>Si el nuevo ESX(i) va a formar parte de una infraestructura virtual previa donde ya hay desplegado un vCenter, podemos realizar la configuración del virtual switch a través del <strong>web client</strong>:</p>

<p><img src="/images/posts/vswitch_vcenter.png" alt="vSwitch - ESX" /></p>

<ol>
<li>Cambiamos la configuración de balanceo a <code>Route based on IP hash</code>.</li>
<li>Ponemos activos los adaptadores (vmnic) que estan en <strong>standby</strong>.</li>
</ol>


<p>En caso contrario (o si nos encontramos más cómodos con el cli), podemos configurar el switch virtual a través de la línea de comandos, accediendo vía SSH al servidor ESX(i):</p>

<p><code>
esxcfg-vswitch -v 60 -p "Management Network" vSwitch0
</code></p>

<h1>Referencias</h1>

<p><a href="http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=1006628">Sample switch port configuration for VLAN and TRUNK MODE</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cisco Catalyst: Origen]]></title>
    <link href="http://atasco.github.io/blog/2014/08/16/cisco-catalyst-origen/"/>
    <updated>2014-08-16T17:35:00+02:00</updated>
    <id>http://atasco.github.io/blog/2014/08/16/cisco-catalyst-origen</id>
    <content type="html"><![CDATA[<p>Antes de seguir con la serie dedicada a <a href="http://atas.co/blog/2014/06/18/screen-la-pantalla-indiscreta/">screen</a>, hacemos un inciso viendo su aplicación directa en la preparación de un switch Cisco Catalyst (C3560 y C2960).</p>

<p>{% img right /images/posts/WSC35608PCS.jpg 375 250 &lsquo;C3560&rsquo; %}</p>

<p>Cuando recibimos un switch, habitualmente realizamos una serie de tareas previas a su configuración:</p>

<ol>
<li>Restauración a los valores de fábrica, si el dispositivo se encontraba previamente configurado.</li>
<li>Revisión de la versión de IOS y actualización de la misma si es necesario.</li>
</ol>


<p>En esta entrada vamos a ver en detalle como realizar estas tareas.</p>

<!-- more -->


<h1>Restaurar el switch a valores de fábrica</h1>

<p>Si se trata de un switch que ha sido utilizado con anterioridad, y que tiene por tanto una configuración establecida, en primer lugar hay que restaurar la configuración a los valores de fábrica.</p>

<p>La manera de hacerlo es sencilla, hay que ejecutar los comandos siguientes en modo privilegiado<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>:</p>

<p><code>
enable
delete flash:vlan.dat
erase startup-config
reload
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>Comando <code>delete flash:vlan.dat</code>: borramos la base de datos de las vlan y la configuración VTP<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>.</li>
<li>Comando <code>erase startup-config</code> (o <code>erase NVRAM:</code>): borramos la configuración.</li>
<li>Comando <code>reload</code>: reiniciamos el switch.</li>
</ul>


<blockquote><p>Debemos responder <strong>no</strong> a la pregunta <em>System configuration has been modified. Save? [yes/no]:</em>.</p></blockquote>

<p><img src="/images/posts/c3560_factory_reset.png" alt="Volver a valores de Fábrica" /></p>

<p>Si desconocemos la contraseña para pasar a modo privilegiado no es posible utilizar los comandos anteriores para borrar la configuración y dejar el switch con los valores de fábrica. En ese caso tendremos que hacer uso de métodos más <em>contundentes</em> consistentes en acceder al switch para recuperar la contraseña utilizada.</p>

<h1>Recuperación de passwords</h1>

<p>En los catalyst de la serie 3560, los pasos a seguir son los siguientes:</p>

<ol>
<li>Conectar el equipo al switch a través del cable de consola (ver la entrada <a href="http://atas.co/blog/2014/06/18/screen-la-pantalla-indiscreta/">Screen, La Pantalla Indiscreta</a>).</li>
<li>Desconectar el switch de la alimentación y volver a conectarlo manteniendo pulsado el botón <em>MODE</em> hasta que el led <em>SYST</em> se mantenga fijo de color verde (cuando se libere el botón <em>MODE</em>, el led <em>SYST</em> comenzara a parpadear).</li>
<li>Seguir las instrucciones mostradas en pantalla.</li>
</ol>


<p><code>
flash_init
dir flash:
rename flash:config.text flash:config.old
boot
</code></p>

<ul>
<li>Comando <code>flash_init</code>: inicializamos la <em>flash</em> del switch.</li>
<li>Comando <code>dir flash:</code>: vemos el contenido de la <em>flash</em> para ver cual es el fichero de configuración <em>(config.text)</em>.</li>
<li>Comando <code>rename flash:config.text flash:config.old</code>: renombramos el fichero de configuración.</li>
<li>Comando <code>boot</code>: cargamos la imagen y entramos en la línea de comandos del switch.</li>
</ul>


<blockquote><p>Debemos responder <strong>yes</strong> a la pregunta <em>Would you like to terminate autoinstall? [yes]:</em> y <strong>no</strong> a la pregunta <em>Would you like to enter the initial configuration dialog? [yes/no]:</em>.</p></blockquote>

<p><img src="/images/posts/c3560_password_recovery_1.png" alt="Recuperación de passwords" /></p>

<p>Recuperamos el fichero de configuración original:</p>

<p><code>
enable
rename flash:config.old flash:config.text
copy flash:config.text system:running-config
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>Comando <code>rename flash:config.old flash:config.text</code>: volvemos a restaurar el fichero de configuración previamente renombrado.</li>
<li>Comando <code>copy flash:config.text system:running-config</code>: cargamos la configuración en memoria.</li>
</ul>


<p>Cambiamos las contraseñas:</p>

<p><code>
configure terminal
enable secret &lt;new_secret_password&gt;
enable password &lt;new_enable_password&gt;
line vty 0 15
password &lt;new_vty_password&gt;
login
line con 0
password &lt;new_console_password&gt;
end
</code></p>

<ul>
<li>Comando <code>configure terminal</code>: entramos en modo configuración.</li>
<li>Comando <code>enable secret &lt;new_secret_password&gt;</code>: cambiamos la contraseña.</li>
<li>Comando <code>enable password &lt;new_enable_password&gt;</code>: cambiamos la contraseña para pasar al modo privilegiado.</li>
<li>Comando <code>line vty 0 15</code>: entramos en la configuración de las terminales remotas.</li>
<li>Comando <code>password &lt;new_vty_password&gt;</code>: cambiamos el password de las terminales remotas.</li>
<li>Comando <code>login</code> habilitamos la petición de contraseña en las terminales remotas.</li>
<li>Comando <code>line con 0</code>: entramos en la configuración de la línea de consola.</li>
<li>Comando <code>password &lt;new_console_password&gt;</code>: cambiamos la contraseña de la línea de consola.</li>
<li>Comando <code>end</code>: salimos del modo de configuración.</li>
</ul>


<p>Guardamos los cambios:</p>

<p><code>
write memory
</code></p>

<ul>
<li>Comando <code>write memory</code>: grabamos la configuración en la NVRAM (nonvolatile random-access memory).</li>
</ul>


<p><img src="/images/posts/c3560_password_recovery_2.png" alt="Recuperación de passwords" /></p>

<h1>Actualización de IOS</h1>

<p>Una vez que tenemos el switch con la configuración <em>limpia</em> debemos revisar la versión de IOS instalada y ver si existe alguna versión posterior que corrija o añada funcionalidades que nos resulten necesarias.</p>

<p>Los pasos que vamos a seguir son los siguientes:</p>

<h2>1. Verificamos la versión de IOS que tiene el switch.</h2>

<p><code>sh
enable
show version
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>comando <code>show version</code>: muestra información sobre el modelo y la versión de IOS.</li>
</ul>


<p><img src="/images/posts/IOS_Version.png" alt="Versión IOS" /></p>

<h2>2. Descargamos la ultima versión de la web de <em>CISCO</em>.</h2>

<p>Nos dirigimos a la web de <em>CISCO</em> y descargamos la versión de IOS para el modelo de switch que vamos a actualizar. También copiaremos el <a href="https://es.wikipedia.org/wiki/MD5">MD5</a> de la versión para realizar la verificación de la misma antes de realizar la instalación.</p>

<h2>3. Si es necesario, para disponer del suficiente espacio en la flash eliminamos la versión instalada.</h2>

<p><code>sh
enable
show flash:
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>comando <code>show flash:</code>: muestra el contenido de la memoria <em>flash</em> del equipo y el espacio disponible. Existe el comando <code>dir flash:</code> que es análogo al anterior.</li>
</ul>


<p><img src="/images/posts/IOS_Flash.png" alt="Flash" /></p>

<p>Si el espacio disponible no es suficiente, debemos borrar la versión de IOS instalada.</p>

<blockquote><p>Al realizar el borrado el switch continua funcionando con normalidad ya que la imagen de IOS se mantiene en la memoria del equipo (sólo se procede a su carga (lectura) cuando se inicia el switch).</p></blockquote>

<p><code>sh
enable
delete /recursive /force flash:&lt;IOS&gt;
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>comando <code>delete /recursive /force flash:&lt;IOS&gt;</code>: fuerza el borrado recursivo del fichero (directorio) <IOS>.</li>
</ul>


<h2>4. Copiamos la nueva imagen al switch.</h2>

<blockquote><p>Para transferir la nueva imagen a la memoria flash del switch necesitamos un servidor TFTP<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</p></blockquote>

<p><code>sh
enable
copy tftp flash:
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>comando <code>copy tftp flash:</code>: copia la nueva imagen desde el servidor TFTP a la memoria flash del switch.</li>
</ul>


<p><img src="/images/posts/IOS_TFTP.png" alt="TFTP" /></p>

<p>Una vez copiada la imagen, verificamos que nada ha ido mal asegurándonos que el valor <em>MD5</em> es el mismo que el que hemos copiado en la web de <em>CISCO</em>.</p>

<p><code>sh
enable
verify /md5 flash:&lt;IOS&gt;
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>comando <code>verify /md5 flash:&lt;IOS&gt;</code>: verifica el valor <em>MD5</em> de la imagen <IOS> que se encuentra en la flash del switch.</li>
</ul>


<p><img src="/images/posts/IOS_Verify.png" alt="Verificar IOS" /></p>

<h2>5. Modificamos el arranque del switch para que se realice desde la IOS instalada.</h2>

<p><code>sh
enable
configure terminal
boot system flash:&lt;IOS&gt;
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>Comando <code>configure terminal</code>: entramos en modo configuración.</li>
<li>Comando <code>boot system flash:&lt;IOS&gt;</code>: configura la imagen <IOS> como imagen de arranque.</li>
</ul>


<p>Comprobamos que la nueva imagen se cargará por defecto en los arranques del sistema.</p>

<p><code>sh
enable
show boot
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>Comando <code>show boot</code>: muestra la imagen de la IOS que se utilizará en el arranque del sistema.</li>
</ul>


<p><img src="/images/posts/IOS_Boot.png" alt="Boot IOS" /></p>

<h2>6. Grabamos la configuración y reiniciamos el switch.</h2>

<p><code>sh
enable
write memory
reload
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>Comando <code>write memory</code>: grabamos la configuración en la NVRAM (nonvolatile random-access memory).</li>
<li>Comando <code>reload</code>: reiniciamos el switch.</li>
</ul>


<h2>7. Verificación final.</h2>

<p>Una vez que el switch se ha reiniciado, comprobamos que la imagen de IOS cargada se corresponde con la versión actualizada.</p>

<p><code>sh
enable
show version
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>comando <code>show version</code>: muestra información sobre el modelo y la versión de IOS.</li>
</ul>


<h1>Referencias</h1>

<p><a href="http://www.cisco.com/c/en/us/support/docs/switches/catalyst-2900-xl-series-switches/24328-156.html">Resetting Catalyst Switches to Factory Defaults</a></p>

<p><a href="http://www.cisco.com/c/en/us/support/docs/switches/catalyst-2950-series-switches/12040-pswdrec-2900xl.html">Cisco Catalyst Fixed Configuration Layer 2 and Layer 3 Switches</a></p>

<p><a href="http://www.cisco.com/c/en/us/support/docs/switches/catalyst-3550-series-switches/41541-190.html">Upgrading Software Images on Catalyst 3550 Series Switches Using the Command Line Interface</a></p>

<p><a href="http://software.cisco.com/download/navigator.html">Software Cisco</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Los switches (routers) <strong>cisco</strong> presentan tres modos de operación. El modo normal, el privilegiado y el de configuración. En el modo normal solo se permite la ejecución de un conjunto reducido de comandos que muestran información básica del dispositivo. El modo privilegiado facilita el acceso a los comandos avanzados, entre ellos el que permite entrar en modo de configuración. <a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>En futuras entradas veremos en detalle que es <a href="https://es.wikipedia.org/wiki/VLAN_Trunking_Protocol">VTP</a>.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="https://es.wikipedia.org/wiki/TFTP">TFTP</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[screen, la pantalla indiscreta]]></title>
    <link href="http://atasco.github.io/blog/2014/06/18/screen-la-pantalla-indiscreta/"/>
    <updated>2014-06-18T22:30:00+02:00</updated>
    <id>http://atasco.github.io/blog/2014/06/18/screen-la-pantalla-indiscreta</id>
    <content type="html"><![CDATA[<p>{% img right /images/posts/screen.png &lsquo;screen&rsquo; %}</p>

<p>Antes de preparar una serie de entradas dedicadas a la configuración y despliegue de switches <em>(Cisco Catalyst)</em> voy a dedicar algunos artículos a la herramienta que utilizo para hacer estas tareas.</p>

<p>La herramienta básica y más importante, al menos durante las labores de configuración inicial, es un cliente que nos permita establecer una conexión vía consola con los switches. Aunque hay muchas alternativas<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, existe una aplicación que por su potencia y versatilidad no debería faltar en ningún equipo que funcione con LiNUX, <a href="http://linux.die.net/man/1/screen">screen</a>.</p>

<p>En este primer post dedicado a <em>screen</em> vamos a ver su funcionalidad como cliente para conectarse a una consola serie junto con los comandos más habituales para trabajar de forma cómoda.</p>

<!-- more -->


<p><em>Screen</em> es una herramienta muy polivalente que nos permite disponer de múltiples ventanas (<a href="https://es.wikipedia.org/wiki/Shell_de_UNIX">shells</a>) dentro de una sesión, con la peculiaridad de que lo que se está ejecutando en estas ventanas se puede mantener en ejecución al abandonarlas. No sólo eso, podemos volver a conectarnos desde cualquier otra consola a una sesión previamente establecida retomando el estado de las ventanas tal como se encontraban al dejarlas.</p>

<p>Además de lo anterior, que de por sí ya es una funcionalidad más que interesante en el trabajo con servidores, nos permite establecer conexiones a través del puerto serie (puerto de consola en switches) con todos aquellos dispositivos que dispongan de este tipo de conectores.</p>

<h1>Conceptos</h1>

<ol>
<li><strong>Sesión:</strong> Es el área de trabajo creada al ejecutar el comando.</li>
<li><strong>Ventana:</strong> Son las <em>shells</em> que se abren dentro de la sesión.</li>
</ol>


<p>También es posible mantener varias ventanas en la misma sesión separadas en <strong>regiones</strong> (horizontales y/o verticales).</p>

<h1>Conexión a una consola serie</h1>

<p>Antes de lanzar el comando para conectarnos a la consola del switch, hay que identificar en el ordenador el dispositivo serie:</p>

<p><code>sh
dmesg | grep tty
</code>
Este comando nos devolverá el dispositivo con una nomenclatura del tipo <code>ttySX</code> o <code>ttyUSBX</code>(donde <em>X</em> es un valor numérico, habitualmente 0).</p>

<p>Con esta información ya podemos utilizar el comando <em>screen</em> para conectarnos:</p>

<p><code>sh
screen /dev/ttyXXXX baud_rate,cs8|cs7,ixon|-ixon,ixoff|-ixoff,istrip|-istrip
</code></p>

<p>Donde:</p>

<p><code>/dev/ttyXXXX</code>: Puerto serie. <br/>
<code>baud_rate</code>: Habitualmente 300, 1200, 9600 o 19200. <br/>
<code>cs8</code> o <code>cs7</code>: Transmisión de 8 o 7 bits por byte. <br/>
<code>ixon</code> o <code>-ixon</code>: Habilita o deshabilita el control de flujo por software (en envío). <br/>
<code>ixoff</code> o <code>-ixoff</code>: Habilita o deshabilita el control de flujo por software (en recepción). <br/>
<code>istrip</code> o <code>-istrip</code>: Elimina o mantiene el octavo bit de cada byte recibido.</p>

<blockquote><p>Todos los switches Cisco Catalyst disponen de un puerto de consola accesible con los parámetros:</p>

<ul>
<li>Connection speed = 9600 bps</li>
<li>Data bits = 8</li>
<li>Parity = None</li>
<li>Stop bits = 1</li>
<li>Flow control = None</li>
</ul>
</blockquote>

<p>Para conectarnos utilizaremos el siguiente comando:</p>

<p><code>sh
screen /dev/ttyUSB0 9600,cs8,-ixon,-ixoff,-istrip
</code></p>

<p>O en su forma abreviada:</p>

<p><code>sh
screen /dev/ttyUSB0
</code></p>

<h1>Comandos básicos</h1>

<p>Como este artículo está enfocado al uso de <em>screen</em> para realizar una conexión vía consola (a un switch), sólo vamos a ver los comandos imprescindibles para realizar esta tarea.</p>

<table>
<thead>
<tr>
<th align="center">Combinación de Teclas </th>
<th align="left"> Tarea </th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>CTRL + a</code> + <code>?</code>      </td>
<td align="left"> Ayuda (lista de comandos)</td>
</tr>
<tr>
<td align="center"><code>CTRL + a</code> + <code>i</code>      </td>
<td align="left"> Información y estado del puerto serie</td>
</tr>
<tr>
<td align="center"><code>CTRL + a</code> + <code>k</code>      </td>
<td align="left"> Cerrar la sesión actual</td>
</tr>
</tbody>
</table>


<h1>Resumen</h1>

<p>Los pasos para conectarnos a una consola serie con <em>screen</em> son los siguientes:</p>

<ol>
<li>Determinar el dispositivo serie en el equipo: <code>dmesg | grep tty</code></li>
<li>Conectarse: <code>screen /dev/ttyUSB0</code></li>
<li>Hacer los cambios necesarios</li>
<li>Desconectarse: <code>CTRL + a</code> + <code>k</code></li>
</ol>


<p>En una próxima entrada seguiremos descubriendo las múltiples capacidades del poderoso <strong>screen</strong>.</p>

<h1>Referencias</h1>

<p><a href="http://www.cyberciti.biz/hardware/5-linux-unix-commands-for-connecting-to-the-serial-console/">5 Linux / Unix Commands For Connecting To The Serial Console</a></p>

<p><a href="https://www.gnu.org/software/screen/manual/screen.html">Screen User&rsquo;s Manual</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Disponemos de clientes completos como <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">Putty</a> y <a href="http://linux.die.net/man/1/minicom">minicom</a> además de herramientas más sencillas como <a href="http://linux.die.net/man/1/cu">cu</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
