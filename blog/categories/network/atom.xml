<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Categoría: network | a t a s c o]]></title>
  <link href="http://atasco.github.io/blog/categories/network/atom.xml" rel="self"/>
  <link href="http://atasco.github.io/"/>
  <updated>2014-09-20T13:06:34+02:00</updated>
  <id>http://atasco.github.io/</id>
  <author>
    <name><![CDATA[aH]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Enlaces troncales Cisco Catalyst - ESX(i)]]></title>
    <link href="http://atasco.github.io/blog/2014/09/20/enlace-troncal-esx-cisco/"/>
    <updated>2014-09-20T20:40:00+02:00</updated>
    <id>http://atasco.github.io/blog/2014/09/20/enlace-troncal-esx-cisco</id>
    <content type="html"><![CDATA[<p>Para realizar la instalación de un servidor ESX(i) en la infraestructura virtual es preciso hacer un análisis previo que nos permita determinar las necesidades. Dentro de estas necesidades la conexión del nuevo servidor en la red es una de las más críticas e importantes.</p>

<p>Existe mucha documentación al respecto en la <a href="http://kb.vmware.com/selfservice/microsites/">base de datos de conocimiento de VMWare</a> así como en sus <a href="https://communities.vmware.com/community">comunidades</a>, pero en este artículo vamos a centrarnos en la conexión del servidor ESX(i) con los switches (Cisco) desplegados en la red.</p>

<!-- more -->


<p>Antes de comenzar con los comandos para la configuración de los switches físico (Cisco Catalyst) y virtual (VMWare vSwitch0), vamos a ver en el siguiente diagrama el diseño final que queremos alcanzar.</p>

<p><img src="/images/posts/trunk_cisco_esx_1.png" alt="Diagrama de conexión Cisco - ESX" /></p>

<table>
<thead>
<tr>
<th align="left">VLAN </th>
<th> Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">60   </td>
<td> Red de Gestión (<strong>management network</strong>)</td>
</tr>
<tr>
<td align="left">70   </td>
<td> Red de VMotion (<strong>VMotion network</strong>)</td>
</tr>
</tbody>
</table>


<h1>Configuración Cisco Catalyst</h1>

<p>En primer lugar configuramos los puertos que intervienen en el <em>EtherChannel</em>:</p>

<p><code>
enable
configure terminal
interface GigabitEthernet1/1
description ESX_LAB-NIC0
channel-group 1 mode on
interface GigabitEthernet1/2
description ESX_LAB-NIC1
channel-group 1 mode on
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>Comando <code>configure terminal</code>: entramos en modo configuración.</li>
<li>Comando <code>interface GigabitEthernet1/1</code>: puerto del switch que vamos a configurar.</li>
<li>Comando <code>description ESX_LAB-NIC0</code>: descripción del puerto.</li>
<li>Comando <code>channel-group 1 mode on</code>: asignamos el puerto al grupo 1 y configuramos el modo incondicional.</li>
</ul>


<p>Ahora pasamos a configurar la interfaz lógica, <em>Port-Channel</em>, asociada a la agrupación de puertos del <em>EtherChannel</em>:</p>

<p><code>
enable
configure terminal
interface port-channel 1
witchport trunk encapsulation dot1q
switchport trunk allowed vlan 60,70
switchport mode trunk
switchport nonegotiate
spanning-tree portfast trunk
</code></p>

<ul>
<li>Comando <code>interface port-channel 1</code>: Port-Channel que vamos a configurar.</li>
<li>Comando <code>switchport trunk encapsulation dot1q</code>: configuramos como protocolo de encapsulación el estándard del IEEE 802.1q (dot1q) ya que los ESX(i) sólo soportan este protocolo.</li>
<li>Comando <code>switchport trunk allowed vlan 60,70</code>: configuramos las VLANs permitidas en el enlace troncal.</li>
<li>Comando <code>switchport mode trunk</code>: habilitamos el enlace troncal.</li>
<li>Comando <code>switchport nonegotiate</code>: como ESX(i) no soporta DTP (Dynamic Trunking Protocol) lo deshabilitamos.</li>
<li>Comando <code>spanning-tree portfast trunk</code>: habilitamos PortFast en el interface cuando se encuentra en modo troncal.</li>
</ul>


<p>Finalmente verificamos la configuración y grabamos los cambios:</p>

<p><code>
show interfaces trunk
show etherchannel summary
copy running-config startup-config
</code></p>

<blockquote><p>Cuando el vSwitch del servidor no está configurado y tenemos varios puertos en el <em>EtherChannel</em> activos no es posible llegar en remoto a la red de gestión (<strong>management network</strong>), para lograrlo lo más sencillo es dejar sólo un puerto del <em>EtherChannel</em> activo.</p></blockquote>

<h1>Configuración vSwitch0 ESX(i)</h1>

<p>Si el nuevo ESX(i) va a formar parte de una infraestructura virtual previa donde ya hay desplegado un vCenter, podemos realizar la configuración del virtual switch a través del <strong>web client</strong>:</p>

<p><img src="/images/posts/vswitch_vcenter.png" alt="vSwitch - ESX" /></p>

<ol>
<li>Cambiamos la configuración de balanceo a <code>Route based on IP hash</code>.</li>
<li>Ponemos activos los adaptadores (vmnic) que están en <strong>standby</strong>.</li>
</ol>


<p>Si no existe un VCenter o si nos encontramos más cómodos con el <em>cli</em>, podemos configurar el switch virtual a través de la línea de comandos, accediendo vía SSH al servidor ESX(i):</p>

<p><code>
esxcfg-vswitch -v 60 -p "Management Network" vSwitch0
</code></p>

<h1>Referencias</h1>

<p><a href="http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=1006628">Sample switch port configuration for VLAN and TRUNK MODE</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cisco Catalyst: Origen]]></title>
    <link href="http://atasco.github.io/blog/2014/08/16/cisco-catalyst-origen/"/>
    <updated>2014-08-16T17:35:00+02:00</updated>
    <id>http://atasco.github.io/blog/2014/08/16/cisco-catalyst-origen</id>
    <content type="html"><![CDATA[<p>Antes de seguir con la serie dedicada a <a href="http://atas.co/blog/2014/06/18/screen-la-pantalla-indiscreta/">screen</a>, hacemos un inciso viendo su aplicación directa en la preparación de un switch Cisco Catalyst (C3560 y C2960).</p>

<p>{% img right /images/posts/WSC35608PCS.jpg 375 250 &lsquo;C3560&rsquo; %}</p>

<p>Cuando recibimos un switch, habitualmente realizamos una serie de tareas previas a su configuración:</p>

<ol>
<li>Restauración a los valores de fábrica, si el dispositivo se encontraba previamente configurado.</li>
<li>Revisión de la versión de IOS y actualización de la misma si es necesario.</li>
</ol>


<p>En esta entrada vamos a ver en detalle como realizar estas tareas.</p>

<!-- more -->


<h1>Restaurar el switch a valores de fábrica</h1>

<p>Si se trata de un switch que ha sido utilizado con anterioridad, y que tiene por tanto una configuración establecida, en primer lugar hay que restaurar la configuración a los valores de fábrica.</p>

<p>La manera de hacerlo es sencilla, hay que ejecutar los comandos siguientes en modo privilegiado<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>:</p>

<p><code>
enable
delete flash:vlan.dat
erase startup-config
reload
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>Comando <code>delete flash:vlan.dat</code>: borramos la base de datos de las vlan y la configuración VTP<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>.</li>
<li>Comando <code>erase startup-config</code> (o <code>erase NVRAM:</code>): borramos la configuración.</li>
<li>Comando <code>reload</code>: reiniciamos el switch.</li>
</ul>


<blockquote><p>Debemos responder <strong>no</strong> a la pregunta <em>System configuration has been modified. Save? [yes/no]:</em>.</p></blockquote>

<p><img src="/images/posts/c3560_factory_reset.png" alt="Volver a valores de Fábrica" /></p>

<p>Si desconocemos la contraseña para pasar a modo privilegiado no es posible utilizar los comandos anteriores para borrar la configuración y dejar el switch con los valores de fábrica. En ese caso tendremos que hacer uso de métodos más <em>contundentes</em> consistentes en acceder al switch para recuperar la contraseña utilizada.</p>

<h1>Recuperación de passwords</h1>

<p>En los catalyst de la serie 3560, los pasos a seguir son los siguientes:</p>

<ol>
<li>Conectar el equipo al switch a través del cable de consola (ver la entrada <a href="http://atas.co/blog/2014/06/18/screen-la-pantalla-indiscreta/">Screen, La Pantalla Indiscreta</a>).</li>
<li>Desconectar el switch de la alimentación y volver a conectarlo manteniendo pulsado el botón <em>MODE</em> hasta que el led <em>SYST</em> se mantenga fijo de color verde (cuando se libere el botón <em>MODE</em>, el led <em>SYST</em> comenzara a parpadear).</li>
<li>Seguir las instrucciones mostradas en pantalla.</li>
</ol>


<p><code>
flash_init
dir flash:
rename flash:config.text flash:config.old
boot
</code></p>

<ul>
<li>Comando <code>flash_init</code>: inicializamos la <em>flash</em> del switch.</li>
<li>Comando <code>dir flash:</code>: vemos el contenido de la <em>flash</em> para ver cual es el fichero de configuración <em>(config.text)</em>.</li>
<li>Comando <code>rename flash:config.text flash:config.old</code>: renombramos el fichero de configuración.</li>
<li>Comando <code>boot</code>: cargamos la imagen y entramos en la línea de comandos del switch.</li>
</ul>


<blockquote><p>Debemos responder <strong>yes</strong> a la pregunta <em>Would you like to terminate autoinstall? [yes]:</em> y <strong>no</strong> a la pregunta <em>Would you like to enter the initial configuration dialog? [yes/no]:</em>.</p></blockquote>

<p><img src="/images/posts/c3560_password_recovery_1.png" alt="Recuperación de passwords" /></p>

<p>Recuperamos el fichero de configuración original:</p>

<p><code>
enable
rename flash:config.old flash:config.text
copy flash:config.text system:running-config
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>Comando <code>rename flash:config.old flash:config.text</code>: volvemos a restaurar el fichero de configuración previamente renombrado.</li>
<li>Comando <code>copy flash:config.text system:running-config</code>: cargamos la configuración en memoria.</li>
</ul>


<p>Cambiamos las contraseñas:</p>

<p><code>
configure terminal
enable secret &lt;new_secret_password&gt;
enable password &lt;new_enable_password&gt;
line vty 0 15
password &lt;new_vty_password&gt;
login
line con 0
password &lt;new_console_password&gt;
end
</code></p>

<ul>
<li>Comando <code>configure terminal</code>: entramos en modo configuración.</li>
<li>Comando <code>enable secret &lt;new_secret_password&gt;</code>: cambiamos la contraseña.</li>
<li>Comando <code>enable password &lt;new_enable_password&gt;</code>: cambiamos la contraseña para pasar al modo privilegiado.</li>
<li>Comando <code>line vty 0 15</code>: entramos en la configuración de las terminales remotas.</li>
<li>Comando <code>password &lt;new_vty_password&gt;</code>: cambiamos el password de las terminales remotas.</li>
<li>Comando <code>login</code> habilitamos la petición de contraseña en las terminales remotas.</li>
<li>Comando <code>line con 0</code>: entramos en la configuración de la línea de consola.</li>
<li>Comando <code>password &lt;new_console_password&gt;</code>: cambiamos la contraseña de la línea de consola.</li>
<li>Comando <code>end</code>: salimos del modo de configuración.</li>
</ul>


<p>Guardamos los cambios:</p>

<p><code>
write memory
</code></p>

<ul>
<li>Comando <code>write memory</code>: grabamos la configuración en la NVRAM (nonvolatile random-access memory).</li>
</ul>


<p><img src="/images/posts/c3560_password_recovery_2.png" alt="Recuperación de passwords" /></p>

<h1>Actualización de IOS</h1>

<p>Una vez que tenemos el switch con la configuración <em>limpia</em> debemos revisar la versión de IOS instalada y ver si existe alguna versión posterior que corrija o añada funcionalidades que nos resulten necesarias.</p>

<p>Los pasos que vamos a seguir son los siguientes:</p>

<h2>1. Verificamos la versión de IOS que tiene el switch.</h2>

<p><code>sh
enable
show version
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>comando <code>show version</code>: muestra información sobre el modelo y la versión de IOS.</li>
</ul>


<p><img src="/images/posts/IOS_Version.png" alt="Versión IOS" /></p>

<h2>2. Descargamos la ultima versión de la web de <em>CISCO</em>.</h2>

<p>Nos dirigimos a la web de <em>CISCO</em> y descargamos la versión de IOS para el modelo de switch que vamos a actualizar. También copiaremos el <a href="https://es.wikipedia.org/wiki/MD5">MD5</a> de la versión para realizar la verificación de la misma antes de realizar la instalación.</p>

<h2>3. Si es necesario, para disponer del suficiente espacio en la flash eliminamos la versión instalada.</h2>

<p><code>sh
enable
show flash:
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>comando <code>show flash:</code>: muestra el contenido de la memoria <em>flash</em> del equipo y el espacio disponible. Existe el comando <code>dir flash:</code> que es análogo al anterior.</li>
</ul>


<p><img src="/images/posts/IOS_Flash.png" alt="Flash" /></p>

<p>Si el espacio disponible no es suficiente, debemos borrar la versión de IOS instalada.</p>

<blockquote><p>Al realizar el borrado el switch continua funcionando con normalidad ya que la imagen de IOS se mantiene en la memoria del equipo (sólo se procede a su carga (lectura) cuando se inicia el switch).</p></blockquote>

<p><code>sh
enable
delete /recursive /force flash:&lt;IOS&gt;
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>comando <code>delete /recursive /force flash:&lt;IOS&gt;</code>: fuerza el borrado recursivo del fichero (directorio) <IOS>.</li>
</ul>


<h2>4. Copiamos la nueva imagen al switch.</h2>

<blockquote><p>Para transferir la nueva imagen a la memoria flash del switch necesitamos un servidor TFTP<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</p></blockquote>

<p><code>sh
enable
copy tftp flash:
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>comando <code>copy tftp flash:</code>: copia la nueva imagen desde el servidor TFTP a la memoria flash del switch.</li>
</ul>


<p><img src="/images/posts/IOS_TFTP.png" alt="TFTP" /></p>

<p>Una vez copiada la imagen, verificamos que nada ha ido mal asegurándonos que el valor <em>MD5</em> es el mismo que el que hemos copiado en la web de <em>CISCO</em>.</p>

<p><code>sh
enable
verify /md5 flash:&lt;IOS&gt;
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>comando <code>verify /md5 flash:&lt;IOS&gt;</code>: verifica el valor <em>MD5</em> de la imagen <IOS> que se encuentra en la flash del switch.</li>
</ul>


<p><img src="/images/posts/IOS_Verify.png" alt="Verificar IOS" /></p>

<h2>5. Modificamos el arranque del switch para que se realice desde la IOS instalada.</h2>

<p><code>sh
enable
configure terminal
boot system flash:&lt;IOS&gt;
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>Comando <code>configure terminal</code>: entramos en modo configuración.</li>
<li>Comando <code>boot system flash:&lt;IOS&gt;</code>: configura la imagen <IOS> como imagen de arranque.</li>
</ul>


<p>Comprobamos que la nueva imagen se cargará por defecto en los arranques del sistema.</p>

<p><code>sh
enable
show boot
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>Comando <code>show boot</code>: muestra la imagen de la IOS que se utilizará en el arranque del sistema.</li>
</ul>


<p><img src="/images/posts/IOS_Boot.png" alt="Boot IOS" /></p>

<h2>6. Grabamos la configuración y reiniciamos el switch.</h2>

<p><code>sh
enable
write memory
reload
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>Comando <code>write memory</code>: grabamos la configuración en la NVRAM (nonvolatile random-access memory).</li>
<li>Comando <code>reload</code>: reiniciamos el switch.</li>
</ul>


<h2>7. Verificación final.</h2>

<p>Una vez que el switch se ha reiniciado, comprobamos que la imagen de IOS cargada se corresponde con la versión actualizada.</p>

<p><code>sh
enable
show version
</code></p>

<ul>
<li>Comando <code>enable</code>: pasamos al modo privilegiado.</li>
<li>comando <code>show version</code>: muestra información sobre el modelo y la versión de IOS.</li>
</ul>


<h1>Referencias</h1>

<p><a href="http://www.cisco.com/c/en/us/support/docs/switches/catalyst-2900-xl-series-switches/24328-156.html">Resetting Catalyst Switches to Factory Defaults</a></p>

<p><a href="http://www.cisco.com/c/en/us/support/docs/switches/catalyst-2950-series-switches/12040-pswdrec-2900xl.html">Cisco Catalyst Fixed Configuration Layer 2 and Layer 3 Switches</a></p>

<p><a href="http://www.cisco.com/c/en/us/support/docs/switches/catalyst-3550-series-switches/41541-190.html">Upgrading Software Images on Catalyst 3550 Series Switches Using the Command Line Interface</a></p>

<p><a href="http://software.cisco.com/download/navigator.html">Software Cisco</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Los switches (routers) <strong>cisco</strong> presentan tres modos de operación. El modo normal, el privilegiado y el de configuración. En el modo normal solo se permite la ejecución de un conjunto reducido de comandos que muestran información básica del dispositivo. El modo privilegiado facilita el acceso a los comandos avanzados, entre ellos el que permite entrar en modo de configuración. <a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>En futuras entradas veremos en detalle que es <a href="https://es.wikipedia.org/wiki/VLAN_Trunking_Protocol">VTP</a>.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="https://es.wikipedia.org/wiki/TFTP">TFTP</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[screen, la pantalla indiscreta]]></title>
    <link href="http://atasco.github.io/blog/2014/06/18/screen-la-pantalla-indiscreta/"/>
    <updated>2014-06-18T22:30:00+02:00</updated>
    <id>http://atasco.github.io/blog/2014/06/18/screen-la-pantalla-indiscreta</id>
    <content type="html"><![CDATA[<p>{% img right /images/posts/screen.png &lsquo;screen&rsquo; %}</p>

<p>Antes de preparar una serie de entradas dedicadas a la configuración y despliegue de switches <em>(Cisco Catalyst)</em> voy a dedicar algunos artículos a la herramienta que utilizo para hacer estas tareas.</p>

<p>La herramienta básica y más importante, al menos durante las labores de configuración inicial, es un cliente que nos permita establecer una conexión vía consola con los switches. Aunque hay muchas alternativas<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, existe una aplicación que por su potencia y versatilidad no debería faltar en ningún equipo que funcione con LiNUX, <a href="http://linux.die.net/man/1/screen">screen</a>.</p>

<p>En este primer post dedicado a <em>screen</em> vamos a ver su funcionalidad como cliente para conectarse a una consola serie junto con los comandos más habituales para trabajar de forma cómoda.</p>

<!-- more -->


<p><em>Screen</em> es una herramienta muy polivalente que nos permite disponer de múltiples ventanas (<a href="https://es.wikipedia.org/wiki/Shell_de_UNIX">shells</a>) dentro de una sesión, con la peculiaridad de que lo que se está ejecutando en estas ventanas se puede mantener en ejecución al abandonarlas. No sólo eso, podemos volver a conectarnos desde cualquier otra consola a una sesión previamente establecida retomando el estado de las ventanas tal como se encontraban al dejarlas.</p>

<p>Además de lo anterior, que de por sí ya es una funcionalidad más que interesante en el trabajo con servidores, nos permite establecer conexiones a través del puerto serie (puerto de consola en switches) con todos aquellos dispositivos que dispongan de este tipo de conectores.</p>

<h1>Conceptos</h1>

<ol>
<li><strong>Sesión:</strong> Es el área de trabajo creada al ejecutar el comando.</li>
<li><strong>Ventana:</strong> Son las <em>shells</em> que se abren dentro de la sesión.</li>
</ol>


<p>También es posible mantener varias ventanas en la misma sesión separadas en <strong>regiones</strong> (horizontales y/o verticales).</p>

<h1>Conexión a una consola serie</h1>

<p>Antes de lanzar el comando para conectarnos a la consola del switch, hay que identificar en el ordenador el dispositivo serie:</p>

<p><code>sh
dmesg | grep tty
</code>
Este comando nos devolverá el dispositivo con una nomenclatura del tipo <code>ttySX</code> o <code>ttyUSBX</code>(donde <em>X</em> es un valor numérico, habitualmente 0).</p>

<p>Con esta información ya podemos utilizar el comando <em>screen</em> para conectarnos:</p>

<p><code>sh
screen /dev/ttyXXXX baud_rate,cs8|cs7,ixon|-ixon,ixoff|-ixoff,istrip|-istrip
</code></p>

<p>Donde:</p>

<p><code>/dev/ttyXXXX</code>: Puerto serie. <br/>
<code>baud_rate</code>: Habitualmente 300, 1200, 9600 o 19200. <br/>
<code>cs8</code> o <code>cs7</code>: Transmisión de 8 o 7 bits por byte. <br/>
<code>ixon</code> o <code>-ixon</code>: Habilita o deshabilita el control de flujo por software (en envío). <br/>
<code>ixoff</code> o <code>-ixoff</code>: Habilita o deshabilita el control de flujo por software (en recepción). <br/>
<code>istrip</code> o <code>-istrip</code>: Elimina o mantiene el octavo bit de cada byte recibido.</p>

<blockquote><p>Todos los switches Cisco Catalyst disponen de un puerto de consola accesible con los parámetros:</p>

<ul>
<li>Connection speed = 9600 bps</li>
<li>Data bits = 8</li>
<li>Parity = None</li>
<li>Stop bits = 1</li>
<li>Flow control = None</li>
</ul>
</blockquote>

<p>Para conectarnos utilizaremos el siguiente comando:</p>

<p><code>sh
screen /dev/ttyUSB0 9600,cs8,-ixon,-ixoff,-istrip
</code></p>

<p>O en su forma abreviada:</p>

<p><code>sh
screen /dev/ttyUSB0
</code></p>

<h1>Comandos básicos</h1>

<p>Como este artículo está enfocado al uso de <em>screen</em> para realizar una conexión vía consola (a un switch), sólo vamos a ver los comandos imprescindibles para realizar esta tarea.</p>

<table>
<thead>
<tr>
<th align="center">Combinación de Teclas </th>
<th align="left"> Tarea </th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>CTRL + a</code> + <code>?</code>      </td>
<td align="left"> Ayuda (lista de comandos)</td>
</tr>
<tr>
<td align="center"><code>CTRL + a</code> + <code>i</code>      </td>
<td align="left"> Información y estado del puerto serie</td>
</tr>
<tr>
<td align="center"><code>CTRL + a</code> + <code>k</code>      </td>
<td align="left"> Cerrar la sesión actual</td>
</tr>
</tbody>
</table>


<h1>Resumen</h1>

<p>Los pasos para conectarnos a una consola serie con <em>screen</em> son los siguientes:</p>

<ol>
<li>Determinar el dispositivo serie en el equipo: <code>dmesg | grep tty</code></li>
<li>Conectarse: <code>screen /dev/ttyUSB0</code></li>
<li>Hacer los cambios necesarios</li>
<li>Desconectarse: <code>CTRL + a</code> + <code>k</code></li>
</ol>


<p>En una próxima entrada seguiremos descubriendo las múltiples capacidades del poderoso <strong>screen</strong>.</p>

<h1>Referencias</h1>

<p><a href="http://www.cyberciti.biz/hardware/5-linux-unix-commands-for-connecting-to-the-serial-console/">5 Linux / Unix Commands For Connecting To The Serial Console</a></p>

<p><a href="https://www.gnu.org/software/screen/manual/screen.html">Screen User&rsquo;s Manual</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Disponemos de clientes completos como <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">Putty</a> y <a href="http://linux.die.net/man/1/minicom">minicom</a> además de herramientas más sencillas como <a href="http://linux.die.net/man/1/cu">cu</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tráfico unicast en switches]]></title>
    <link href="http://atasco.github.io/blog/2014/03/12/switch-unicast/"/>
    <updated>2014-03-12T18:25:00+01:00</updated>
    <id>http://atasco.github.io/blog/2014/03/12/switch-unicast</id>
    <content type="html"><![CDATA[<p>Realizando una auditoría en la red para determinar su estado se observa, en el equipo en el que se está realizando la captura, tráfico unicast destinado a otros equipos.</p>

<p>Este tráfico es bastante elevado en la <em>VLAN de Internet</em>, mientras que en las <em>VLANes de Servicio</em> el tráfico unicast recogido es el normal en una red conmutada.</p>

<p>Aunque el tráfico unicast detectado no provoca problemas en la red, si es importante conocer la causa del mismo a fin de evitarlo en lo posible.</p>

<blockquote><p>Aunque la estabilidad y el rendimiento de la red no se ve afectado, la presencia de tráfico unicast evidencia un agujero de seguridad importante que es preciso subsanar.</p></blockquote>

<!-- more -->


<h1>Funcionamiento básico de un switch</h1>

<p>Un switch es un dispositivo de red de capa 2, es decir, procesa y envía los paquetes basándose en las direcciones MAC.</p>

<p>Un switch &ldquo;aprende&rdquo; a lo largo del tiempo donde se encuentran las MACs destino de los paquetes (a que puerto está esa MAC conectada) a medida que el tráfico atraviesa sus puertos . Si desconoce donde se encuentra una MAC destino envía paquetes unicast (<em>unicast flooding</em>) a todos los puertos (excepto a aquel del que proviene el paquete) y cuando se recibe la respuesta de vuelta registra la MAC asociada a ese puerto <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<p>Por ejemplo, si un <em>host A</em> envía un paquete a un <em>host B</em> conectado a la misma VLAN de un switch, inicialmente la tabla CAM del switch se encuentra vacía y el switch reenvía el paquete a todos sus puertos.</p>

<p><img src="/images/posts/switch_traffic_1.png" alt="Tráfico switch: IDA" /></p>

<table>
<thead>
<tr>
<th align="left">MAC            </th>
<th align="right"> Puerto</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">0000.00c0.0001 </td>
<td align="right"> Fa0/1</td>
</tr>
</tbody>
</table>


<p>Cuando el <em>host B</em> recibe el paquete responde al <em>host A</em> momento en el que el switch también aprende la MAC del mismo.</p>

<p><img src="/images/posts/switch_traffic_2.png" alt="Tráfico switch: VUELTA" /></p>

<table>
<thead>
<tr>
<th align="left">MAC            </th>
<th align="right"> Puerto</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">0000.00c0.0001 </td>
<td align="right"> Fa0/1</td>
</tr>
<tr>
<td align="left">0000.00c0.0002 </td>
<td align="right"> Fa0/2</td>
</tr>
</tbody>
</table>


<p>Un switch &ldquo;olvida&rdquo; las direcciones MAC aprendidas después de un tiempo<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> de modo que el switch necesita ser capaz de aprender de nuevo en que puertos se encuentran las MACs. Cuando esto sucede, comienza de nuevo el proceso de inundar todos los puertos con tráfico unicast para esperar la respuesta del equipo con la MAC correspondiente y aprenderla de nuevo. Esta es la razón por la que se produce tráfico unicast cada cierto tiempo<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</p>

<h1>Orígenes del tráfico unicast</h1>

<p>La presencia de tráfico unicast puede ocurrir por diversas causas en una red, lo importante es diferenciar cuando este tráfico esta dentro de parámetros normales y cuando puede provocar problemas.</p>

<p>En los siguientes puntos se recogen aquellas causas que pueden dar lugar al llamado <em>unicast flooding</em> causante de posibles problemas.</p>

<h2>Rutas asimétricas</h2>

<p>Se produce esta situación cuando un paquete sigue una ruta de origen a destino distinta a la ruta de vuelta al origen (esto ocurre habitualmente en redes enrutadas, capa 3).</p>

<p>Para entender el proceso que da lugar a esta situación hay que recordar que en un dispositivo de capa 3 (router) existen dos tablas<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>:</p>

<ul>
<li><p><strong>ARP (Address Resolution Protocol):</strong> Mantiene las relaciones entre las direcciones IP y las direcciones MAC con la finalidad de facilitar las comunicaciones IP en un dominio de broadcast (capa 2)<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>.</p></li>
<li><p><strong>CAM (Content Addressable Memory):</strong> Mantiene las relaciones entre las direcciones MAC y el puerto(s) físico del switch<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>.</p></li>
</ul>


<blockquote><p>Por alguna oscura razón, en los switches Cisco con capacidades de routing (capa 3) el valor por defecto para la permanencia de las entradas en la tabla ARP es de 4 horas mientras que el tiempo de permanencia por defecto en la tabla CAM es de sólo 5 minutos.</p></blockquote>

<p>Vamos a centrarnos en el siguiente esquema para entender mejor como se produce este tipo de problema:</p>

<p><img src="/images/posts/unicast_asymmetric_routing.png" alt="Unicast Rutas Asimétricas" /></p>

<p>Vemos que inicialmente las tablas (ARP y CAM) en los switches (<em>core 1</em> y <em>core 2</em>) se encuentran vacías, el <em>host A</em> tiene el <em>core 1</em> como ruta por defecto y el <em>host B</em> tiene como ruta por defecto al <em>core 2</em>.</p>

<p><strong>[1]</strong> Imaginemos ahora que desde el <em>host A</em> se hace un ping al <em>host B</em>, enviando un paquete ICMP echo a través de su ruta de enlace, <em>core 1</em>. Como el <em>host A</em> desconoce la MAC de su gateway, envía en primer lugar un <em>ARP Request</em> para obtener la MAC de su IP (10.1.1.1).</p>

<p><img src="/images/posts/unicast_asymmetric_routing_1.png" alt="Unicast Rutas Asimétricas: ICMP Echo" /></p>

<table>
<thead>
<tr>
<th align="left">host A (ARP)            </th>
<th align="center"> core 1 (CAM)           </th>
<th align="center"> core 1 (ARP)             </th>
<th align="center"> core 2 (ARP) </th>
<th align="center"> core 2 (CAM) </th>
<th align="right"> host B (ARP)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">10.1.1.1 0003.6bf1.2a01 </td>
<td align="center"> 0000.0c00.0001 1 Gi2/1 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center">              </td>
<td align="center">              </td>
<td></td>
</tr>
</tbody>
</table>


<p><strong>[2-3]</strong> El <em>core 1</em> desconoce la MAC del <em>host B</em>, de modo que envía un <em>ARP Request</em>. Cuando recibe el <em>ARP Replay</em> ambos <em>cores</em> aprenden el puerto origen del <em>host B</em>, con esta información el <em>core 1</em> enruta los paquetes al <em>core 2</em> a través de la <em>VLAN 2</em> (conoce la IP del <em>host B</em> y sabe que pertenece a la <em>VLAN 2</em>).</p>

<p><img src="/images/posts/unicast_asymmetric_routing_2.png" alt="Unicast Rutas Asimétricas: Routing Core 1" /></p>

<table>
<thead>
<tr>
<th align="left">host A (ARP)            </th>
<th align="center"> core 1 (CAM)           </th>
<th align="center"> core 1 (ARP)             </th>
<th align="center"> core 2 (ARP) </th>
<th align="center"> core 2 (CAM)           </th>
<th align="right"> host B (ARP)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">10.1.1.1 0003.6bf1.2a01 </td>
<td align="center"> 0000.0c00.0001 1 Gi2/1 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center">              </td>
<td align="center"> 0000.0c00.0002 2 Gi2/1 </td>
<td align="right"> 10.1.2.1 0003.6bf1.2a01</td>
</tr>
<tr>
<td align="left">                        </td>
<td align="center"> 0000.0c00.0002 2 Gi1/1 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center">              </td>
<td align="center">                        </td>
<td align="right"> </td>
</tr>
</tbody>
</table>


<p><strong>[4]</strong> El <em>core 2</em> dispone de la información necesaria en su tabla CAM y entrega el <em>ICMP Echo Request</em> al <em>host B</em>.</p>

<p><img src="/images/posts/unicast_asymmetric_routing_3.png" alt="Unicast Rutas Asimétricas: Entrega Host B" /></p>

<table>
<thead>
<tr>
<th align="left">host A (ARP)            </th>
<th align="center"> core 1 (CAM)           </th>
<th align="center"> core 1 (ARP)             </th>
<th align="center"> core 2 (ARP)             </th>
<th align="center"> core 2 (CAM)           </th>
<th align="right"> host B (ARP)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">10.1.1.1 0003.6bf1.2a01 </td>
<td align="center"> 0000.0c00.0001 1 Gi2/1 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center"> 0000.0c00.0002 2 Gi2/1 </td>
<td align="right"> 10.1.2.1 0003.6bf1.2a01</td>
</tr>
<tr>
<td align="left">                        </td>
<td align="center"> 0000.0c00.0002 2 Gi1/1 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center">                          </td>
<td align="center">                        </td>
<td align="right"> 10.1.2.2 0003.6bf1.2a02</td>
</tr>
</tbody>
</table>


<p><strong>[5]</strong> Ahora, el <em>host B</em> tiene que responder con un <em>ICMP Echo Replay</em> al <em>host A</em>. Como desconoce la MAC de su ruta por defecto envía un <em>ARP Request</em> a su gateway (10.1.2.2).</p>

<p><img src="/images/posts/unicast_asymmetric_routing_replay.png" alt="Unicast Rutas Asimétricas: ICMP Reply" /></p>

<table>
<thead>
<tr>
<th align="left">host A (ARP)            </th>
<th align="center"> core 1 (CAM)           </th>
<th align="center"> core 1 (ARP)             </th>
<th align="center"> core 2 (ARP)             </th>
<th align="center"> core 2 (CAM)           </th>
<th align="right"> host B (ARP)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">10.1.1.1 0003.6bf1.2a01 </td>
<td align="center"> 0000.0c00.0001 1 Gi2/1 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center"> 0000.0c00.0002 2 Gi2/1 </td>
<td align="right"> 10.1.2.1 0003.6bf1.2a01</td>
</tr>
<tr>
<td align="left">                        </td>
<td align="center"> 0000.0c00.0002 2 Gi1/1 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center"> 0000.0c00.0001 1 Gi1/1 </td>
<td align="right"> 10.1.2.2 0003.6bf1.2a02</td>
</tr>
</tbody>
</table>


<p><strong>[6-7]</strong> Una vez que el <em>host B</em> envía el <em>Echo Replay</em> al <em>core 2</em> rellena con los datos su tabla ARP, pero como desconoce la MAC del <em>host A</em> envía un <em>ARP Request</em> a su IP (10.1.1.10). Con su respuesta agrega ese dato a sus tablas CAM y ARP, y enruta la respuesta al <em>core 2</em> a través de la VLAN 1.</p>

<table>
<thead>
<tr>
<th align="left">host A (ARP)            </th>
<th align="center"> core 1 (CAM)           </th>
<th align="center"> core 1 (ARP)             </th>
<th align="center"> core 2 (ARP)             </th>
<th align="center"> core 2 (CAM)           </th>
<th align="right"> host B (ARP)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">10.1.1.1 0003.6bf1.2a01 </td>
<td align="center"> 0000.0c00.0001 1 Gi2/1 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center"> 0000.0c00.0002 2 Gi2/1 </td>
<td align="right"> 10.1.2.1 0003.6bf1.2a01</td>
</tr>
<tr>
<td align="left">10.1.1.2 0003.6bf1.2a02 </td>
<td align="center"> 0000.0c00.0002 2 Gi1/1 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center"> 0000.0c00.0001 1 Gi1/1 </td>
<td align="right"> 10.1.2.2 0003.6bf1.2a02</td>
</tr>
</tbody>
</table>


<p><strong>[8]</strong> El <em>core 1</em> dispone de la información necesaria en su tabla CAM para entregar el <em>ICMP Echo Reply</em> al <em>host A</em>. La respuesta llega a su destino y se finaliza el flujo quedando las tablas de todos los elementos con los datos de IPs y MACs actualizados.</p>

<blockquote><p>El <em>host A</em> tiene como gateway el <em>core 1</em> en la VLAN 1 mientras que el <em>host B</em> tiene como gateway el <em>core 2</em> en la VLAN 2, es decir, existe una ruta asimétrica. La única manera de que el <em>core 1</em> aprenda la MAC del <em>host B</em>  es cuando el <em>host B</em> responde a un <em>ARP Request</em> del <em>core 1</em> (y al contrario con el <em>host A</em> y el <em>core 2</em>).</p></blockquote>

<p><strong>¿Qué ocurre cuando pasan cinco minutos?</strong></p>

<p>A los cinco minutos el <em>core 1</em> elimina de su tabla CAM las entradas de cuyas direcciones MAC no recibe tráfico, por lo que deja de conocer el puerto asociado a la MAC del <em>host B</em>. Como la tabla ARP no se vacía hasta que hayan transcurrido cuatro horas el <em>core 1</em> sigue conociendo la MAC asociada a la IP del <em>host B</em> (lo mismo ocurre con el <em>core 2</em> y el <em>host A</em>) y como resultado de esto el <em>core 1</em> tratará todo paquete con destino la MAC del <em>host B</em> como unicast (el <em>core 1</em> enviará el paquete con destino al <em>host B</em> a todos sus puertos produciéndose el <em>unicast flooding</em>).</p>

<table>
<thead>
<tr>
<th align="left">host A (ARP)            </th>
<th align="center"> core 1 (CAM)           </th>
<th align="center"> core 1 (ARP)             </th>
<th align="center"> core 2 (ARP)             </th>
<th align="center"> core 2 (CAM)           </th>
<th align="right"> host B (ARP)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">10.1.1.1 0003.6bf1.2a01 </td>
<td align="center"> 0000.0c00.0001 1 Gi2/1 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center"> 0000.0c00.0002 2 Gi2/1 </td>
<td align="right"> 10.1.2.1 0003.6bf1.2a01</td>
</tr>
<tr>
<td align="left">10.1.1.2 0003.6bf1.2a02 </td>
<td align="center">                        </td>
<td align="center"> 10.1.2.10 0000.00c0.0002 </td>
<td align="center"> 10.1.1.10 0000.00c0.0001 </td>
<td align="center">                        </td>
<td align="right"> 10.1.2.2 0003.6bf1.2a02</td>
</tr>
</tbody>
</table>


<h2>Cambios en la topología</h2>

<p>Hay eventos en la red que pueden provocar que la tabla CAM del switch se libere con una frecuencia mayor a la configurada (<em>aging time</em>), uno de estos eventos es el cambio de topología debido a STP, <em>Spanning Tree Protocol</em>.</p>

<p>Los cambios en la topología reducen el tiempo de las entradas en la tabla CAM de los 300 segundos habituales a 15 segundos en el caso del STP. En redes que hacen uso del RSTP, <em>Rapid Spanning Tree Protocol</em>, las direcciones MAC se liberan de la tabla CAM de forma inmediata.</p>

<p>En una red estable, los cambio de topología son pocos y se producen muy de vez en cuando. Las razones para que estos cambios tengan lugar son:</p>

<ul>
<li>Switches nuevos que se añaden a la red.</li>
<li>Eliminación de switches viejos.</li>
<li>Cambios de configuración realizados por el administrador.</li>
</ul>


<p>En estos casos, el cambio de topología es normal y necesario para el correcto funcionamiento de la red<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>.</p>

<p>Ahora bien, cuando se produce de forma continua tráfico unicast en una red estable es por la configuración incorrecta de los puertos asignados a los equipos (PCs, Hosts, Impresoras&hellip;). Estos equipos no participan en el proceso STP, por lo tanto los cambios de estado de sus interfaces de red (<em>LINK UP/LINK DOWN</em>) no deberían dar lugar a un cambio de topología STP<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup> y la forma de asegurarnos que esto sea así es utilizar la característica <em>PortFast</em> en la configuración de los puertos de los switches en los que están conectados estos equipos.</p>

<h2>Microsoft NLB</h2>

<p>Los cluster de Microsoft funcionan utilizando una IP virtual (VIP), que se asigna a la dirección MAC del cluster. El problema es que la dirección MAC del cluster no se utiliza para enviar tráfico, sino que este tráfico se cursa desde los nodos del mismo que tienen direcciones MAC distintas.<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup></p>

<p><img src="/images/posts/microsoft_nlb.png" alt="Microsoft NLB" /></p>

<table>
<thead>
<tr>
<th align="center">switch (CAM)           </th>
<th align="center"> switch (ARP)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0d00.0d00.0d01 1 Fa0/1 </td>
<td align="center"> 192.168.1.1 0d00.0d00.0d01</td>
</tr>
<tr>
<td align="center">0000.00c0.0001 2 Fa0/2 </td>
<td align="center"> 10.1.1.1 0000.00c0.0001</td>
</tr>
<tr>
<td align="center">0000.00c0.0002 3 Fa0/3 </td>
<td align="center"> 10.1.1.2 0000.00c0.0002</td>
</tr>
</tbody>
</table>


<p>Como los switches no conocen en que puerto se encuentra la MAC del cluster (<em>10.1.1.111 &ndash; 03BF.0000.1111</em>, no hay un puerto físico del switch en la que se encuentra conectada), enviarán los paquetes a todos los puertos de la VLAN, resultando que todos los miembros del cluster recibirán el tráfico y el driver NBL en cada uno de los nodos determinará que nodo se hace cargo de la petición.</p>

<p>El problema es que todos los equipos en la misma VLAN también recibirán el tráfico destinado al cluster NBL ya que este tráfico se envía a todos los puertos.</p>

<h2>Teaming</h2>

<p>En aquellos casos en los que un host necesita enviar y/o recibir volúmenes de tráfico muy elevados que no puede asumir un sólo enlace es necesario agrupar (<em>team, bond&hellip;</em>) más de un adaptador de red para aumentar el ancho de banda.</p>

<p>Al igual que en el host se agrupan los interfaces de red, el switch debe conocer que puertos pertenecen al mismo enlace lógico y realizar el ether-channel correspondiente con los mismos. De otra manera habrá problemas con entradas incorrectas en la CAM que darán lugar a la presencia de tráfico unicast.</p>

<h2>LLenado de la tabla CAM</h2>

<p>Cuando en una red hay una cantidad de host muy elevada, la tabla CAM puede llegar a llenarse. Si esto curre, el switch comenzará a enviar el trafico para aquellas direcciones que no tiene en la CAM a todos los puertos produciéndose el <em>unicast flooding</em>.</p>

<h1>Cómo detectarlo</h1>

<p>La forma más sencilla de detectar la presencia de tráfico unicast anómalo en la red es mediante la realización de capturas. Existen diversas herramientas para realizar estas capturas, siendo las más extendidas las que aparecen a continuación.</p>

<h2>TCPDUMP</h2>

<p>``` sh</p>

<h1>Realizando las capturas desde el host 10.11.1.111 con MAC 00:19:99:57:5e:d5</h1>

<p>tcpdump -i eth0 ether host not 00:19:99:57:5e:d5 and host not 10.11.1.111 and not broadcast and not multicast
```</p>

<h2>WIRESHARK</h2>

<p>``` sh</p>

<h1>excluir tráfico multicast y broadcast</h1>

<p>!(eth.ig == 1)</p>

<h1>excluir mac del router &ndash; switch (xx.yy.zz.tt.uu.vv)</h1>

<p>!(eth.dst == xx.yy.zz.tt.uu.vv)
```</p>

<h1>Soluciones</h1>

<h2>Rutas asimétricas</h2>

<p>Se pueden realizar cambios en la configuración de lo switches para remediar esta situación:</p>

<ul>
<li>Ajustando el periodo de permanencia de las entradas en la tabla CAM a 14400 segundos (aunque es mejor un valor más alto de 4 horas, por ejemplo 6).</li>
<li>Cambiar el tiempo de la tabla ARP a 5 minutos (300 segundos).</li>
<li>Cambiar los tiempos en ambas tablas (CAM y ARP) para que tengan el mismo valor (por ejemplo 10 minutos, 600 segundos)</li>
</ul>


<p>Usaremos preferentemente el método de cambiar el tiempo de permanencia en la tabla CAM a 14400 segundos (mejor 21600):</p>

<p>``` sh</p>

<h1>CISCO IOS</h1>

<p>core1(config)#mac address-table aging-time [time in seconds] [vlan id]</p>

<h1>CISCO CatOS</h1>

<p>core1(config)#set cam agingtime [vlan id] [time in seconds]
```</p>

<h2>Cambios en la topología</h2>

<p>Es necesario identificar el puerto del switch causante del cambio, lo primero es determinar si ha ocurrido un cambio en la topología:</p>

<p>``` sh</p>

<h1>CISCO IOS</h1>

<p>core1#show mac-address table aging vlan [vlan-id]</p>

<h1>CISCO CatOS</h1>

<p>core1#show cam agingtime [vlan-id]
```</p>

<p>Posteriormente identificamos el puerto causante del cambio:</p>

<p>``` sh</p>

<h1>CISCO IOS</h1>

<p>core1#show spantree-tree vlan [vlan-id] detail</p>

<h1>CISCO CatOS</h1>

<p>core1#show spantree statistics [mod/port] [vlan-id]
```</p>

<p>Finalmente configuramos el puerto añadiendo:</p>

<p>``` sh</p>

<h1>CISCO IOS</h1>

<p>core1(config-if)#spanning-tree port-fast
```</p>

<h2>Microsoft NLB</h2>

<p>No existe una solución válida y sencilla que nos permita evitar el <em>unicast flooding</em> cuando tenemos clusters NLB en la red. Una forma de mitigar el problema es crear una VLAN independiente para los nodos del cluster.</p>

<p>Ahora bien, en el caso de tener un NLB en modo multicast, existe la posibilidad de evitar el tráfico unicast añadiendo de forma estática en las tablas ARP y CAM las IP y MAC asociadas a la IP virtual del cluster.</p>

<p>Por ejemplo, si la IP virtual es la 10.10.10.10 y la MAC 1111.1111.1111 en la VLAN 100 donde los nodos del cluster están conectados a los puertos Gi0/1 y Gi0/2:</p>

<p>``` sh</p>

<h1>ROUTER</h1>

<p>core1#conf t
core1#arp 10.10.10.10 1111.1111.1111 ARPA</p>

<h1>SWITCH</h1>

<p>core1#conf t
core1#mac-address-table static 1111.1111.1111 vlan 100 int gi0/1 gi0/2
```</p>

<h2>Teaming</h2>

<p>La manera de evitar el <em>unicast flooding</em> cuando hay host en la red con interfaces agrupados es verificar y realizar una configuración correcta del team (bond) en el lado del host y del ether-channel en el switch, asegurando el que el protocolo utilizado y los puertos agregados son los correctos.</p>

<h2>Llenado de la tabla CAM</h2>

<p>En este caso, la solución consiste en segmentar la red en subredes (VLAN) más pequeñas.</p>

<h1>Referencias</h1>

<p><a href="http://www.cisco.com/en/US/products/hw/switches/ps700/products_tech_note09186a00801d0808.shtml">Unicast Flooding in Switched Campus Networks</a></p>

<p><a href="http://www.cisco.com/en/US/tech/tk648/tk362/technologies_tech_note09186a0080094afd.shtml#t8">Understanding and Troubleshooting HSRP Problems in Catalyst Switch Networks</a></p>

<p><a href="http://www.cisco.com/en/US/products/hw/switches/ps708/products_tech_note09186a00807347ab.shtml">Catalyst 6500/6000 Switches ARP or CAM Table Issues Troubleshooting</a></p>

<p><a href="http://www.ciscozine.com/2012/04/15/unicast-flooding-due-to-asymmetric-routing/">Unicast flooding due to asymmetric routing</a></p>

<p><a href="http://www.ciscopress.com/articles/article.asp?p=336872">Troubleshooting Unicast Flooding Due to Topology</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Los switches almacenan en tablas dinámicas (content addressable memory table, CAM table) las relaciones entre puertos y MACs. Estas tablas tienen un periodo de vida (timeout) determinado (en el caso de switches cisco, por defecto son 5 minutos) y un tamaño también limitado.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Las MAC puede pasar a estar inactivas debido a que el dispositivo se encuentra apagado o bien a que los equipos se han conectado a otro puerto distinto del switch.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Este tráfico unicast es normal en la red y no supone un riesgo para la misma.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>En realidad son tres, también esta la tabla TCAM (Ternary Content Addressable Memory), pero no es necesaria para entender el comportamiento del <em>unicast flooding</em>.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Cuando un <strong>host B</strong> quiere enviar información a un <strong>host A</strong> y no tiene en su tabla ARP la direccion MAC del <strong>host A</strong>, el <strong>host B</strong> genera un mensaje de broadcast que llega a todos los host del dominio de broadcast (ARP Request) en el que se encuentra para obtener la dirección MAC asociada a la IP del <strong>host A</strong>. Sólo el <strong>host A</strong> responde al mensaje con su dirección MAC.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>A medida que los paquetes llegan a los puertos del switch este aprende la dirección MAC que se encuentra detrás de los mismos y los guarda en la tabla CAM. En la tabla CAM se registra la dirección MAC, el puerto, la VLAN y el timestamp. Si la dirección MAC aprendida por un switch en un puerto se mueve a otro puerto diferente, la dirección MAC y el timestamp se registran para el último puerto y la entrada previa se borra. Si la dirección MAC se encuentra registrada en la tabla CAM en el mismo puerto, únicamente se actualiza el timestamp en la entrada existente.<a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
<li id="fn:7">
<p>Las notificaciones de cambio de topología (<em>TCN</em>) están diseñadas para corregir la tablas de reenvío cuando se produce un cambio. Esto es necesario para evitar cortes en las comunicaciones, ya que cuando se produce un cambio de topología algunos destinos dejan de estar accesibles a través de unos determinados puertos para ser accesibles por otros. TCN funciona reduciendo el tiempo de permanencia de las entradas en la tabla CAM, de modo que si una dirección no se vuelve a aprender se eliminará de la tabla y se producirá el envío de tráfico unicast por todos los puertos del switch.<a href="#fnref:7" rev="footnote">&#8617;</a></p></li>
<li id="fn:8">
<p>Los puertos del switch asignados a los hosts no están involucrados en los cambios de topología STP o en el envío de las BPDUs.<a href="#fnref:8" rev="footnote">&#8617;</a></p></li>
<li id="fn:9">
<p>Es más complejo que todo esto, en función de como se configura el cluster NLB (multicast o unicast) el comportamiento del tráfico varía.<a href="#fnref:9" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
